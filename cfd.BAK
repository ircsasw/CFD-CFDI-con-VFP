****************************************************************************
** CFD.PRG
**
** Libreria de clases para generacion del Comprobante Electronico Digital
** en Mexico, segun las indicaciones del SAT
**
** Autores: Victor Espina / Arturo Ramos / Baltazar Moreno
**
** Version: 3.4
** 
** Basado en colaboraciones de:
** - Halcon Divino
** - Carlos Figueroa
** 
**
** NOTA IMPORTANTE #1
** A partir de la version 2.4 de esta libreria, el metodo Sellar() de la clase
** CFDComprobante valida que el certificado sea valido y este vigente. Si el 
** certificado no pasa estas pruebas, el metodo no generara el sello y devolvera
** .F., almacenando en la propiedad CFDConf.ultimoError la descripcion de problema.
**
** Se puede obviar esta validacion almacenando .T. en la propiedad CFDConf.modoPruebas
**
** 
** NOTA IMPORTANTE #2
** Si esta teniendo problemas con las funciones o metodos que invocan OpenSSL
** y su carpeta SSL esta ubicada en una ruta que contiene nombres largos o 
** espacios en blanco, puede que el problema se deba a que la creacion de nombres
** cortos (8.3) esta desactivada a nivel de Windows.  Por favor, revise en su
** Register la clave:
**
** HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem\NtfsDisable8dot3NameCreation
**
** y asegurese que su valor sea cero. Si esta en "1", haga el cambio y reinicie
** su sistema. Si el valor ya estaba en cero o el problema persiste luego de 
** cambiarlo a cero, mueva su carpeta SSL a una ruta que no contenga nombres de
** mas de 8 caracteters ni contenga espacios en blanco.
**
**
** NOTA IMPORTANTE #3
** La libreria OpenSSL requiere de las librerias de runtime de VC++ 2008, la cual
** puede no estar disponible en algunos equipos, causando problemas con el sellado
** de los CFDs (y todas las demas funciones de la libreria que dependan de OpenSSL).
**
** Para solucionar este problema, descargue e instale las librerias necesarias desde
** este link (cortesia de Carlos Omar Figueroa):
**
** http://www.microsoft.com/downloads/en/details.aspx?familyid=9B2DA534-3E03-4391-8A4D-074B9F2BC1BF&displaylang=en
**
**
** NOTA IMPORTANTE #4
** Para generar la representación impresa del CFD se utiliza el procedimiento CFDToCursor() para
** pasar los nodos del XML a cursores y así poder reportarlos. Por regla los saltos de línea y
** retornos de carro no estan permitidos en un XML, entonces que pasa si hay un concepto en el
** comprobante donde sea muy importante mostrar información en líneas adicionales sobre todo para
** coneptos muy largos donde se desglozan condiciones u otra información.
** 
** Para solucionar este problema se incluye un parametro adicional a CFDPrint() con el que podemos
** indicar que se va a remplazar los conceptos obtenidos por CFDToCursor() en el cursor QCO por los 
** que estan en el entorno de datos; aquí se supone que en el entorno de datos tenemos un cursor 
** llamado curConceptos con los conceptos del comprobante tal como se guardaron en la base de datos.
**
**
** NOTA IMPORTANTE #5
** A partir de la version 3.2 la propiedad Addenda de la clase CFDComprobante cambia su funcionamiento
** completamente, por lo que ya no es compatible con su uso en versiones anteriores.  
**
**
****************************************************************************
**       H I S T O R I A L    D E    M O D I F I C A C I O N E S
****************************************************************************
**
** VES  Nov 14, 2011    - Cambios en metodo CrearXML para incluir el manejo de addendas
**                      - Nuevas propiedades nodeName y schemaLocation de la clase ICFDAddenda
**   
** VES  Nov 12, 2011	- Version 3.4
**						- Nueva propiedad Complemento de la clase CFDComprobante
**						- Nuevo uso de la propiedad CFDAddenda de CFDComprobante
**						- Eliminacion de la propiedad CFDAddendas y la clase homonima, introducidos en Oct 10, 2011
**						- Mejoras en el metodo CrearXML() para incluir la generacion del nodo Addenda y/o Comprobante
**                      - Nueva funcion CFDBuffer()
**
** VES  Nov 11, 2011    - Version 3.3
**                      - Nuevas propiedades nameSpace, nodeName y createNodeLInks en clase XMLNOdeClass
**                      - Nueva propiedad createNodeLinks en clase XMLParser, para permitir multiples nodos hermanos con el mismo nombre
**                      - Nuevo metodo ToString() en clase XMLParser
**                      - Mejoras en metodos Open(), Save() e iSaveNode() en clase XMLParser para manejar NameSpaces
**                      - Mejoras en metodo AddNode() de XMLNodeClass para manejar NameSpaces
**                      - Mejoras en el metodo CrearXML() de la clase CFD para implementar las mejoras en las clases XMLParser y XMLNodeClass
**
** VES  Oct 10, 2011	- Nueva clase ICFDAddenda
**                      - Nueva clase CFDAddendas 
**                      - Nueva propiedad Addendas en CFDComprobante
**						- Cambio en CFDPrint() para sustituir uso de clausula READWRITE para matener la compatibilidad con versiones anteriores de VFP 
**
** BMJ  Oct 7, 2011		- Nueva función CFDGoogleQR() que genera un archivo PNG con el QR del CFDI
**                        Parámetros: tcDato, que es la cadena que contendrá codificada el CBB.
**                        Ésta función se ayuda de otra: CFDGetEscaped() la cual convierte los 
**						  caracteres recibidos como parámetro recibido que no son soportados en 
**                        una URL por su secuencia de escape.
**
** ARC  Oct 7, 2011		- Nueva función CFDEnviarPorCorreoAdjuntos para envier por correo
**						  Parámetros: pcDestinatario, pcAsunto, pcCuerpo, pcCFD, pcPDF
**						  Envia CFD y PDF por correo. A diferencia de CFDEnviarPorCorreo esta permite
**   					  adjuntar el PDF ya creado lo cuál es útil cuando se utilizan diferente
**						  formatos para la representación impresa o para enviar comprobantes
**					      que no generó nuestro sistema como puede ser el caso de algunos PACs
**						  que junto con el timbre regresan el PDF
**
** ARC  Oct 6, 2011		- Nueva función CFDCadenaCBB(pcArchivoXML) para obtener la cadena
**						  necesaria para generar el CBB para la representación
**						  impresa de un CFDI desde un XML timbrado
**
** ARC  Ago 7, 2011		- Adaptaciones en CFDValidarXML para poder validar CFDI
**
** ARC  Ago 6, 2011		- Nueva propiedad XMLVersion de la clase CFDConf
**						- Nueva propiedad incluirBOM de la clase CFDConf
**						- Nuevo atributo Moneda de la clase CFDComprobante para CFDI
**						- Nuevo atributo TipoCambio de la clase CFDComprobante para CFDI
**
** ARC  Jul 13, 2011	- Se modifica en CrearXML() que se incluya el BOM en el XML
** 
** VES  Ene 10, 2011	- Cambios en formato CFD
**
** VES  Ene 6, 2011		- Correcciones varias en funcion CrearFactura().
** 						- Se incluyeron los atributos opcionales totalImpuestosRetenidos
**              		  y totalImpuestosTrasladados al generar el XML.
**
** VES	Ene 5, 2011		- Nueva funcion CFDProbarOpenSSL()
**						- Nueva propiedad formatoImpresion de CFDConf
**						- Modificaciones varias en la funcion CFDPrint()
**						- Mejoras en el metodo Sellar() de CFDComprobante
**
** VES	Ene 4, 2011		- Se reprogramo el metodo _GenCadenaOriginal de CFDComprobante
**						  para utilizar la funcion CFDExtraerCadenaOriginal()
** 						- Nuevo objeto CFDCertificado
**						- Nueva propiedad "ultimoCertificado" de la clase CFDConf
**						- Nueva funcion de cache en el metodo LeerCertificado() de la
**						  clase CFDComprobante.
** 						- Se incluyo una nueva seccion de retenciones en el formato CFD.FRX
**						- Modificaciones para permitir la extraccion de la cadena original
**						  en modo offline
**
** VES 	Ene 3, 2011		- Se corrigio un problema en la rutina CFDPrint() que dejaba
**						  la impresora PDFCreator pre-configurada para auto-save.
**						- Se incluyo una descripción por defecto cuando se indica
**						  un descuento pero no un motivo.
**						- Correccion menor en la funcion CFDValidarXML().
**						- Modificacion en _FixStr() para eliminar los saltos de linea.
**
** VES	Dic 30, 2010	- Se renombre la funcion NTOCESP() por CFDNTOCESP()
**						- Nueva clase CFDReporteMensual
**						- Nueva propiedad ubicacionRepositorio en CFDConf
**
** VES	Dic 29, 2010	- Nueva funcion CFDVigenciaCert().
**						- Nueva propiedad UltimoError en CFDConf
**						- Nueva propiedad modoPruebas en CFDConf
**						- Nueva propiedad Version en CFDConf
**                      - Nueva funcion CFDLeerCertificado()
**						- Cambios en metodo LeerCertificado() de CFDComprobante
**						- Cambios en el metodo Sellar() de CFDComprobante para
**						  verificar la valide del certificado antes de sellar
**						- Nueva funcion CFDValidarXML()
**                      - Nueva funcion CFDGenerarSello()
**						- Nueva propiedad "MetodoDigest" de CFDConf
** 						- Correcciones varias en CFDExtraerCadenaOriginal()
**
** VES 	Dic 28, 2010	- Cambios en varias rutinas para manejar el tema
**						  de los nombres de archivo largos
**						- Cambios en la funcion NTOCESP() para adaptarla
**						  a los usos en Mexico
**
** VES 	Dic 27, 2010	- Nueva Utilidad CFDToCursor()
**                      - Nueva utilidadd CFDPrint()
**                      - Correccion en genCadenaOriginal para el caso de
**						- importe cero en impuestos
**						- Nueva utilidad CFDExtraerCadenaOriginal()\
**                      - Nuevo procedure CFDInit()
**                      - Nuevo procedure CFDEnviarPorCorreo()
**
** VES	Dic 20, 2010	Version original
**
****************************************************************************
**  I N T E R F A C E
****************************************************************************
*!*	LEYENDA:

*!*	Clase {Clase Base}
*!*	==================
*!*	+Atributo-Obligatorio [{Clase-Atributo}]
*!*	-Atributo-Opcional
*!*	=Propiedad [nota]
*!*	@Metodo(parametros) [ = {Tipo-valor-retornado}]



*!*	CFDComprobante {Custom}
*!*	=======================
*!*	+Version = "2.0"
*!*	+Folio 
*!*	+Fecha 
*!*	+Sello [1]
*!*	+noAprobacion 
*!*	+anoAprobacion
*!*	+formaDePago
*!*	+noCertificado 
*!*	+subTotal 
*!*	+Total 
*!*	+tipoDeComprobante 
*!*	+Emisor {CFDEmisor}
*!*	+Receptor {CFDReceptor}
*!*	+Conceptos {CFDConceptos}
*!*	-Serie
*!*	-Certificado 
*!*	-condicionesDePago 
*!*	-Descuento 
*!*	-motivoDescuento 
*!*	-metodoDePago 
*!*	+Impuestos {CFDImpuestos}
*!*	-Addenda {ICFDAddenda}
*|* -Complemento [ICFDAddenda]
*!*	=cadenaOriginal [2]
*!* =ubicacionOpenSSL [3]
*!*	@Sellar(archivo-key, password) [4]
*!*	@crearXml(archivo-destino)
*!*	@importarXml(archivo-origen) = {True | False}
*!*	@exportarDbf(ruta-destino)
*!*	@enviarPorCorreo(remitente, destinatario, asunto, texto)

*!*	[1] El valor de este atributo sera llenado automaticamente por la clase al invocar el metodo Sellar()
*!*	[2] Esta propiedad es de solo lectura y devuelve la cadena original en base al contenido de los atributos de la clase
*!* [3] Esta propiedad contiene la carpeta donde esta instalado el OpenSSL
*!* [4] El metodo devuelve .T. si se pudo sellar el certificado o .F. si no fue posible. La propiedad ultimoError de CFDConf
*!*     contendra la explicacion de porque no se pudo sellar


*!*	CFDPersona {Custom}
*!*	===================
*!*	+RFC
*!*	+Nombre
*!*	+domicilioFiscal {CFDDireccion}  [3]
*!*	-expedidoEn {CFDDireccion} [4]

*!*	[3] En el caso del receptor, este atributo se utiliza para el atributo "Domicilio" en el XML
*!*	[4] En el caso del receptor, este atrbuto no es tomado en cuenta


*!*	CFDDireccion {Custom}
*!*	=====================
*!*	+Calle
*!*	+Municipio
*!*	+Estado
*!*	+Pais
*!*	+codigoPostal
*!*	-noExterior
*!*	-noInterior
*!*	-Colonia
*!*	-Localidad
*!*	-Referencia


*!*	CFDConceptos {CFDCollection}
*!*	============================
*!*	@Add(cantidad, descripcion, precioUnitario, importe) = {CFDConcepto}


*!*	CFDConcepto {Custom}
*!*	====================
*!*	+Cantidad
*!*	+Descripcion
*!*	+valorUnitario
*!*	+Importe
*!*	-noIdentificacion
*!*	-informacionAduanera {CFDInformacionAduanera}
*!*	-cuentaPredial {CFDCuentaPredial}


*!*	CFDInformacionAduanera {Custom}
*!*	===============================
*!*	+Numero
*!*	+Fecha
*!*	+Aduana


*!*	CFDCuentaPredial {Custom}
*!*	=========================
*!*	+Numero


*!*	CFDImpuestos {Custom}
*!*	=====================
*!*	=totalImpuestosRetenidos
*!*	=totalImpuestosTrasladados
*!*	-Retenciones {CFDRetenciones}
*!*	-Traslados {CFDTraslados}


*!*	CFDRetenciones {CFDCollection}
*!*	==============================
*!*	@Add(impuesto, importe) = {CFDRetencion}


*!*	CFDTraslados {CFDCollection}
*!*	============================
*!*	@Add(impuesto, tasa, importe) = {CFDTraslado}


*!*	CFDRetencion {Custom}
*!*	=====================
*!*	+Impuesto
*!*	+Importe


*!*	CFDTraslado {Custom}
*!*	====================
*!*	+Impuesto
*!*	+Tasa
*!*	+Importe


*!*	CFDAddenda {CFDCollection}  (Obsoleto)
*!*	==========================
*!*	@Add(nombre, valor)



*!*	CFDCollection {Custom}
*!*	======================
*!*	=Count
*!*	=Items[1..Count]
*!*	@Add(item)


*!*	CFDCertificado (Custom)
*!*	=======================
*!*	=Valido		
*!*	=Vigente	
*!*	=Certificado

	
*!*	ICFDAddenda [Custom]
*!*	===================
*!* -nodeName
*!* -schemaLocation
*!*	-NSTag
*!*	-NSUrl
*!*	@ToString()




****************************************************************************
**  U T I L I D A D E S
****************************************************************************
**
** CFDInit()
** Inicializacion de las distintas rutinas contenidas en la libreria. Se debe
** invocar una vez antes de acceder al resto de las clases y funciones. Este
** procedure crea un objeto publico llamado CFDConf, el cual contiene las
** siguiente propiedades configurables:
**
** Version					Version actual de la libreria CFD
** OpenSSL					Ubicacion del archivo OPENSSL.EXE
** SMTPServer				Servidor SMTP a utilizar para el envio de correos
** SMTPPort					Puerto a utilizar dentro del servidor SMTP
** SMTPUseSSL				Boolean. Indica si se utilizar SSL o no para enviar el correo
** SMTPUserName				Nombre del usuario con el que se autenticara la session en el servidor SMTP
** SMTPPassword				Contrasena del usuario para autenticacion en el servidor SMTP
** MailSender				Direccion electronica del remitente del correo
** ultimoError				Contiene el texto del ultimo error ocurrido
** modoPruebas				Indica si se esta trabajando en modo de pruebas		
** metodoDigest				Ultimo metodo utilizado para la firma del sello digital
** ubicacionRepositorio		Incia la ubicacion del repositorio de CFDs
** ultimoCertificado		Instancia de la clase CFDCertificado con los datos del ultimo certificado utilizado
** formatoImpresion			Formato de impresion a utilizar. Por defecto es CFD.FRX
** XMLversion				Define la versión del XML a crear. Por defecto es versión 2. (2 = CFD y 3 = CFDI)
** icluirBOM				Agrega el BOM correspondiente a los archivos codificados en UTF-8. Por defecto es falso
**
**
** CFDOpenSSL([pcOpenSSL])
** Permite determinar si la libreria OpenSSL esta bien instalada y funciona correctamente. El parametro
** opcional pcOpenSSL permite indicar la ruta donde esta instalada la libreria OpenSSL; si no se
** indica se asume el valor de CFDConf.openSSL. La funcion retorna .T. si la libreria OpenSSL esta
** instalada y funciona correctamente, o .F. en caso contrario. Si la libreria funciona correctamente
** la funcion almacena en CFDConf.ultimoError la version actual de la libreria; si ocurrio algun error
** con la prueba, la descripcion del error ocurrido se almacena tambien en CFDConf.ultimoError.
**
**
** CFDToCursor(pcXML [,pcPrefix])
** Recibe un CFD en formato XML y genera varios cursores contentivos de los
** datos del CFD. El parametro opcion pcPrefix permite indicar el prefijo
** que se desea utilizar para los nombres de los cursores. Si no se indica
** se asume "Q". La funcion crea 5 cursores, a saber:
**
** QDG	Datos generales
** QCO	Conceptos
** QAD	Informacion aduanala
** QRT	Retenciones
** QTR	Traslados
**
**
** CFDPrint(pcXML [, plPreview, plPDFMode, pcPDFTarget, plReplaceCO])
** Recibe un CFD en formato XML y genera una representacion impresora del
** mismo. El parametro opcion plPreview permite mostrar una vista previa
** del comprobante antes de imprimirlo. El parametro opcional plPDFMode permite
** indicar que se desea generar una representacion del CFD en formato PDF. Si
** se indica .T. en este parametro, se debe indicar el nombre y ubicacion del
** archivo PDF a generar en el parametro pcPDFTarget. El parametro opcional
** plReplaceCO indica que los conceptos sean reemplazados por los almacenados
** en el cursor curConceptos para poder utilizar saltos de línea y retornos
** de carro en la descripción de los conceptos ya que estos no son válidos
** en el XML.
**
** IMPORTANTE: Para utilizar la funcion de generar un CFD en formato PDF se
** requiere instalar el producto gratuito PDFCreator (www.pdfcreator.com).
**
**
** CFDExtraerCadenaOriginal(pcXML, pcRutaOpenSSL)
** Permite extraer la cadena original de un CFD indicado. El parametro
** ocRutaOpenSSL contiana la ruta completa a la carpeta donde este
** instalado el OpenSSL.EXE
**
**
** CFDEnviarPorCorreo(pcDestinatario, pcAsunto, pcTexto, pcCFD [,plAdjuntarPDF])
** Permita enviar por correo un CFD generado. Si se indica .T. en el parametro
** opcion plAdjuntarPDF, se asumira que e parametro pcCFD contiene el nombre
** de un CFD en formato XML, y se utilizara el mismo para generar una representacion
** en PDF del comprobante y se anexara tambien al correo.
**
**
** CFDValidarKeyCer(pcArchivoKEY, pcArchivoCER, pcPassword [, pcOpenSSL])
** Permite determinar si el archivp KEY corresponde con el archivo CER
** indicados. Si no se indica el parametro opcion pcOpenSSL, se asume el
** valor de la propiedad CFDConf.openSSL. La fnucion retorna .T. si los
** archivos KEY y CER son complementarios o .F. si no lo son u ocurrio algun
** error. La descripcion del ultimo error ocurrido se almacena en CFDConf.ultimoError
**
**
** CFDLeerCertificado(pcARchivoCER [,pcOpenSSL])
** Lee un certificado indicado y devuelve un objeto con informacion del mismo. 
**
**
** CFDValidarXML(pcArchivoXML, pcArchivoKey, pcPassword, pcMetodo, pcOpenSSL)
** Determina si el XML indicado esta bien formado y cumple con las especificaciones
** del SAT. Adicionalmente valida que el sello este correcto.
**
**
** CFDGenerarSello(pcCadenaOriginal, pcArchivoKey, pcPassword, pcMetodo, pcOpenSSL)
** Permite generar un sello a partir de una cadena original dada. 
** 
** CFDEnviarPorCorreoAdjuntos(pcDestinatario, pcAsunto, pcCuerpo, pcCFD, pcPDF)
** Permite enviar correo adjuntando XML y PDF (sin regenerarlo)
**
** CFDCadenaCBB(pcArchivoXML)
** Genera la cadena para convertir a QR Code (CBB)
*****************************************************************************

#DEFINE CRLF	 CHR(13)+CHR(10)
#DEFINE True	.T.
#DEFINE False	.F.


*-- CFDInit (Procedure)
*   Crea el objeto public CFDConf, el cual contiene
*   configuraciones generales de uso en varios de 
*   los metodos y funciones de la libreria
*
PROCEDURE CFDInit
 *
 PUBLIC CFDConf
 CFDConf = CREATE("Custom")
 CFDConf.addProperty("Version","3.0")
 CFDConf.AddProperty("OpenSSL",ADDBS(FULLPATH(".\SSL")))
 CFDConf.AddProperty("SMTPServer","")
 CFDConf.AddProperty("SMTPPort","")
 CFDConf.AddProperty("SMTPUseSSL",.T.)
 CFDConf.AddProperty("SMTPAuthenticate",.T.)
 CFDConf.AddProperty("SMTPUserName","")
 CFDConf.AddProperty("SMTPPassword","")
 CFDConf.AddProperty("MailSender","")
 CFDConf.AddProperty("UltimoError","")
 CFDConf.addProperty("modoPruebas",.F.)
 CFDConf.addProperty("metodoDigest","md5")
 CFDConf.addProperty("ubicacionRepositorio",".\CFD")
 CFDConf.addProperty("ultimoCertificado",NULL)
 CFDConf.addProperty("formatoImpresion","CFD.FRX")
 CFDConf.addProperty("XMLversion",2)
 CFDConf.addProperty("incluirBOM",.F.)
 
 DECLARE Sleep IN kernel32 INTEGER dwMilliseconds  
 
 DECLARE INTEGER GetShortPathName IN kernel32;
    STRING    lpszLongPath,;
    STRING  @ lpszShortPath,;
    INTEGER   cchBuffer

 *
ENDPROC


*-- CFDComprobante (Clase)
*   Representa a un comprobante digital
*
DEFINE CLASS CFDComprobante AS Custom
 *
 *-- Atributos requeridos
 Version = IIF(CFDConf.XMLversion=3, "3.0", "2.0")
 Folio = 0
 Fecha = {}
 Sello = ""
 noAprobacion = 0
 anoAprobacion = 0
 formaDePago = "Pago en una sola exhibición"
 noCertificado = ""
 subTotal = 0.00
 Total = 0.00
 tipoDeComprobante = ""
 Emisor = NULL
 Receptor = NULL
 Conceptos = NULL
 
 
 *-- Atributos opcionales
 Serie = "" 
 Certificado = "" 
 condicionesDePago = "" 
 Descuento = 0.00
 motivoDescuento = ""
 metodoDePago = "" 
 Impuestos = NULL
 Addenda = NULL
 Complemento = NULL  && VES Nov 12, 2011
 
 
 *-- Atributos de CFDI
 Moneda = NULL
 TipoCambio = NULL
 
 
 *-- Propiedades
 cadenaOriginal = ""   && Solo-lectura
 ubicacionOpenSSL = ".\SSL"
  
 
 *-- Getters / Setters
 PROCEDURE cadenaOriginal_Access
  RETURN THIS._genCadenaOriginal()
 ENDPROC
 PROCEDURE cadenaPriginal_Assign(vNewVal)
 ENDPROC 
 
 
 *-- Constructor de la clase
 PROCEDURE Init
  THIS.Emisor = CREATEOBJECT("CFDPersona")
  THIS.Receptor = CREATEOBJECT("CFDPersona")
  THIS.Conceptos = CREATEOBJECT("CFDConceptos")
  THIS.Impuestos = CREATEOBJECT("CFDImpuestos")
  THIS.ubicacionOpenSSL = CFDConf.OpenSSL
 ENDPROC
 
 
 *-- Metodos
 
 *-- _genCadenaOriginal (Metodo)
 *   Genera la cadena original que sirve de base para generar el sello digital. El codigo original
 *   pertenece al amigo Halcon Divino, y fue adaptado para el uso dentro de esta clase.
 *
 *   VES Ene 4, 2011
 *   Se cambio el codigo para obtener la cadena original directametne del XML aplicando el archivo
 *   XSLT proporcionado por el SAT. De esta forma nos garantizamos que no haya diferencia entre
 *   la cadena original generada por la clase y la que genera el SAT a partir del XML, lo cual 
 *   elimina los problemas de sellado por diferencia en la cadena original.
 *
 PROCEDURE _genCadenaOriginal()
  *
  LOCAL cTempFile
  cTempFile = GetTempFile("XML")
  THIS.CrearXML(cTempFile)
  
  LOCAL cStr
  cStr = CFDExtraerCadenaOriginal(cTempFile)
  
  ERASE (cTempFile)
  
  RETURN cStr
  *
 ENDPROC
 
 
 *-- _fixStr (Metodo)
 *   Recibe una cadena y realiza los siguientes cambios:
 *   a) Sustituye cualquier caracter invalido por el caracter "."
 *   b) Elimina los espacios en blanco al inicio y al final de la cadena
 *   c) Elimina cualquier secuencia de espacios en blanco repetidos dentro de la cadena
 *   d) Si la cadena resultante contiene al menos 1 caracter, se le anade la cadena
 *      indicada en el parametro pcSep
 *
 *   La funcion fue reeacrita a partir de la funcion QtarChrInval() de Halcon Divino, a fin
 *   de simplificar el codigo y depurarlo. El metodo utilizado por Halcon Divino para incluir
 *   cada elemento en la cadena original implicaba una doble llamada a QtarChrInval() para 
 *   cada valor en la cadena:
 *
 *   cStr  = cStr  + Iif(Len(QtarChrInval(valor)) = 0, "" ,QtarChrInval(valor) + "|") 
 *
 *   Este codigo se simplifica y mejora haciendo una sola invocacion a fixStr:
 *
 *   cStr = cStr + THIS._fixStr(valor, "|")
 *
 *   Adicionalmente se incluyo codigo para permitir que la funcion reciba cualquier tipo
 *   de datos, haciendo la conversion adecuada segun el tipo. En los casos donde el parametro
 *   de entraada no sea un string, no se realiza la verificacion de caracteres invalidos
 *
 HIDDEN PROCEDURE _fixStr(puValue, pcSep)
  *
  IF PCOUNT() = 1
   pcSep = ""
  ENDIF
  
  LOCAL cType
  cType = VARTYPE(puValue)
  
  DO CASE
     CASE cType = "N" 
          IF EMPTY(puValue)
           RETURN ""
          ENDIF
          RETURN ALLT(STR(puValue,15,2)) + pcSep
          
     CASE cType = "D"
          IF EMPTY(puValue)
           RETURN ""
          ENDIF
          RETURN STR(YEAR(puValue),4) + "-" + PADL(MONTH(puValue),2,"0") + "-" + PADL(DAY(puValue),2,"0") + pcSEP
          
     CASE cType = "T"
          IF EMPTY(puValue)
           RETURN ""
          ENDIF
          RETURN STR(YEAR(puValue),4) + "-" + PADL(MONTH(puValue),2,"0") + "-" + PADL(DAY(puValue),2,"0") + "T" + ;
                 PADL(HOUR(puValue),2,"0") + ":" + PADL(MINUTE(puValue),2,"0") + ":" + PADL(SEC(puValue),2,"0") + pcSEP     
     
     CASE cType = "X"  && Valor NULL
          RETURN ""
  ENDCASE
  
  
  LOCAL cFixed
  cFixed = ALLTRIM(puValue)
  cFixed = STRT(STRT(STRT(STRT(STRT(cFixed,[&],[&amp;]),[<],[&lt;]),[>],[&gt;]),["],[&quot;]),['],[&apos;])
  cFixed = STRT(cFixed, CHR(13)+CHR(10), "")
 
  DO WHILE AT(SPACE(2), cFixed) <> 0
   cFixed = STRTRAN(cFixed,SPACE(2),SPACE(1))
  ENDDO
 
  IF LEN(cFixed) > 0 AND !EMPTY(pcSep)
   cFixed = cFixed + pcSep
  ENDIF
  
  RETURN cFixed
  *
 ENDPROC
 

 *-- Sellar (Metodo)
 *   Genera el sello digital del comprobante y actualiza los atributos apropiados
 *
 PROCEDURE Sellar(pcArchivoKey, pcPassword)
  *
  CFDConf.ultimoError = ""

  *-- Si la fecha del comprobante es igual o posterior al 1-1-2011, se cambia
  *   el metodo MD5 por SHA-1
  *
  LOCAL cMetodo
  cMetodo = "md5"
  IF YEAR(THIS.fecha) > 2010 
   cMetodo = "sha1"
  ENDIF
  CFDConf.metodoDigest = cMetodo
  
  *-- Se obtiene la cadena original
  *
  LOCAL cCadenaOriginal
  cCadenaOriginal = THIS.cadenaOriginal
  IF EMPTY(cCadenaOriginal)
   CFDConf.ultimoError = "No se pudo obtener la cadena original. Utilize CFDProbarOpenSSL() para verificar el funcionamiento de la libreria OpenSSL"
   RETURN .F.
  ENDIF
  
  
  *-- Se genera el sello para la cadena original
  *
  THIS.Sello = CFDGenerarSello(cCadenaOriginal, pcArchivoKey, pcPassword, cMetodo, THIS.ubicacionOpenSSL)
  
  RETURN !EMPTY(THIS.Sello)
  *
 ENDPROC
 
 
 *-- leerCertificado
 *   Lee el archivo de certificado indicado y actualiza
 *   los atributos apropiados
 *
 *   VES Ene 4, 2011
 *   Se utiliza la propiedad CFDConf.ultimoCertificado como
 *   un "cache" para evitar leer innecesariamente el mismo
 *   certificado varias veces seguidas
 *
 PROCEDURE leerCertificado(pcArchivoCER)
  *
  *-- Se lee el certificado (solo si es necesario)
  LOCAL oCert  
  IF ISNULL(CFDConf.ultimoCertificado) OR CFDConf.ultimoCertificado.Archivo <> LOWER(pcArchivoCER)
   oCert = CFDLeerCertificado(pcArchivoCER)
   IF ISNULL(oCert)
    RETURN NULL
   ENDIF  
   CFDConf.ultimoCertificado = oCert
  ELSE
   oCert = CFDConf.ultimoCertificado 
   ?"Cached!"
  ENDIF 
  
  IF oCert.Valido AND (oCert.Vigente OR CFDConf.modoPruebas)
   THIS.Certificado = oCert.Certificado
   THIS.noCertificado = oCert.Serial
  ENDIF
  
  RETURN oCert
  *
 ENDPROC
 
 
 *-- CrearXML (Metodo)
 *   Crea el archivo XML que representa el comprobante
 *
 PROCEDURE CrearXML(pcArchivo, plValidar, pcArchivoKey, pcPassword, pcMetodo)
  *
  #DEFINE CFD_OPCIONAL		.T.  
  
  CFDConf.ultimoError = ""

  LOCAL oParser
  oParser = CREATEOBJECT("XmlParser")
  WITH oParser
   *
   .indentString = ""
   .New()
   
   *-- Nodo "Comprobante"
   .XML.addNode("Comprobante")
   IF THIS.Version > "2.0"  && VES Nov 11, 2011
    .XML._Comprobante.NameSpace = "cfdi"  && Al anadir el NS "Cfdi" al nodo comprobante, todos los subnodos lo heredaran automaticamente
   ENDIF
   WITH .XML._Comprobante
    IF ALLTRIM(THIS.version) = "2.0"
    	.addProp("xmlns","http://www.sat.gob.mx/cfd/2")
    	.addProp("xmlns:xsi","http://www.w3.org/2001/XMLSchema-instance")
   		.addProp("xsi:schemaLocation","http://www.sat.gob.mx/cfd/2 http://www.sat.gob.mx/sitio_internet/cfd/2/cfdv2.xsd")
   	ELSE 
   		.addProp("xmlns:cfdi","http://www.sat.gob.mx/cfd/3")
    	.addProp("xmlns:xsi","http://www.w3.org/2001/XMLSchema-instance")
   		.addProp("xsi:schemaLocation","http://www.sat.gob.mx/cfd/3 http://www.sat.gob.mx/sitio_internet/cfd/3/cfdv3.xsd")
   	ENDIF 
    .addProp("version",THIS._fixStr(THIS.version))
    .addProp("serie",THIS._fixStr(THIS.serie),CFD_OPCIONAL)
    .addProp("folio",THIS._fixStr(STR(THIS.folio,10,0)))
    .addProp("fecha",THIS._fixStr(THIS.fecha))
    IF ALLTRIM(THIS.version) = "2.0"
	    .addProp("noAprobacion",THIS._fixStr(STR(THIS.noAprobacion,10,0)))
    	.addProp("anoAprobacion",THIS._fixStr(STR(THIS.anoAprobacion,10,0)))
    ELSE 
    	.addProp("Moneda",THIS._fixStr(THIS.moneda),CFD_OPCIONAL)
    	.addProp("TipoCambio",THIS._fixStr(THIS.tipocambio),CFD_OPCIONAL)   
    ENDIF 
    .addProp("formaDePago",THIS._fixStr(THIS.formaDePago))
    *.addProp("",THIS._fixStr(THIS.))
    .addProp("condicionesDePago",THIS._fixStr(THIS.condicionesDePago),CFD_OPCIONAL)
    .addProp("subTotal",THIS._fixStr(STR(THIS.subTotal,15,2)))
    .addProp("descuento",THIS._fixStr(TRANSFORM(THIS.Descuento,"@Z 999999999999.99")),CFD_OPCIONAL)
    .addProp("motivoDescuento",THIS._fixStr(THIS.motivoDescuento),CFD_OPCIONAL)
    .addProp("total",THIS._fixStr(STR(THIS.total,15,2)))
    .addProp("metodoDePago",THIS._fixStr(THIS.metodoDePago),CFD_OPCIONAL)
    .addProp("tipoDeComprobante",THIS._fixStr(THIS.tipoDeComprobante))
    .addProp("noCertificado",THIS.noCertificado)
    .addProp("certificado",THIS.Certificado)
    .addProp("sello",THIS.sello)
   ENDWITH
  
   *-- Nodo "Emisor"
   .XML._Comprobante.addNode("Emisor")
   WITH .XML._Comprobante._Emisor
    .addProp("rfc",CHRT(THIS._fixStr(THIS.Emisor.rfc),".-",""))
    .addProp("nombre",THIS._fixStr(THIS.Emisor.nombre))
    .addNode("DomicilioFiscal")
    WITH ._DomicilioFiscal
     .addProp("calle",THIS._fixStr(THIS.Emisor.DomicilioFiscal.Calle))
     .addProp("noExterior",THIS._fixStr(THIS.Emisor.DomicilioFiscal.noExterior),CFD_OPCIONAL)
     .addProp("noInterior",THIS._fixStr(THIS.Emisor.DomicilioFiscal.noInterior),CFD_OPCIONAL)
     .addProp("colonia",THIS._fixStr(THIS.Emisor.DomicilioFiscal.colonia),CFD_OPCIONAL)
     .addProp("localidad",THIS._fixStr(THIS.Emisor.DomicilioFiscal.localidad),CFD_OPCIONAL)
     .addProp("referencia",THIS._fixStr(THIS.Emisor.DomicilioFiscal.referencia),CFD_OPCIONAL)
     .addProp("municipio",THIS._fixStr(THIS.Emisor.DomicilioFiscal.municipio))
     .addProp("estado",THIS._fixStr(THIS.Emisor.DomicilioFiscal.estado))
     .addProp("pais",THIS._fixStr(THIS.Emisor.DomicilioFiscal.pais))
     .addProp("codigoPostal",THIS._fixStr(THIS.Emisor.DomicilioFiscal.codigoPostal),CFD_OPCIONAL)
    ENDWITH
    
    IF NOT EMPTY(THIS.Emisor.ExpedidoEn.Calle)
     .addNode("ExpedidoEn")
     WITH ._ExpedidoEn
      .addProp("calle",THIS._fixStr(THIS.Emisor.ExpedidoEn.Calle))
      .addProp("noExterior",THIS._fixStr(THIS.Emisor.ExpedidoEn.noExterior),CFD_OPCIONAL)
      .addProp("noInterior",THIS._fixStr(THIS.Emisor.ExpedidoEn.noInterior),CFD_OPCIONAL)
      .addProp("colonia",THIS._fixStr(THIS.Emisor.ExpedidoEn.colonia),CFD_OPCIONAL)
      .addProp("localidad",THIS._fixStr(THIS.Emisor.ExpedidoEn.localidad),CFD_OPCIONAL)
      .addProp("referencia",THIS._fixStr(THIS.Emisor.ExpedidoEn.referencia),CFD_OPCIONAL)
      .addProp("municipio",THIS._fixStr(THIS.Emisor.ExpedidoEn.municipio))
      .addProp("estado",THIS._fixStr(THIS.Emisor.ExpedidoEn.estado))
      .addProp("pais",THIS._fixStr(THIS.Emisor.ExpedidoEn.pais))
      .addProp("codigoPostal",THIS._fixStr(THIS.Emisor.ExpedidoEn.codigoPostal),CFD_OPCIONAL)
     ENDWITH
    ENDIF
   ENDWITH
   
   
   *-- Nodo "Receptor"
   .XML._Comprobante.addNode("Receptor")
   WITH .XML._Comprobante._Receptor
    .addProp("rfc",CHRT(THIS._fixStr(THIS.Receptor.rfc),".-",""))
    .addProp("nombre",THIS._fixStr(THIS.Receptor.nombre))
    .addNode("Domicilio")
    WITH ._Domicilio
     .addProp("calle",THIS._fixStr(THIS.Receptor.DomicilioFiscal.Calle),CFD_OPCIONAL)
     .addProp("noExterior",THIS._fixStr(THIS.Receptor.DomicilioFiscal.noExterior),CFD_OPCIONAL)
     .addProp("noInterior",THIS._fixStr(THIS.Receptor.DomicilioFiscal.noInterior),CFD_OPCIONAL)
     .addProp("colonia",THIS._fixStr(THIS.Receptor.DomicilioFiscal.colonia),CFD_OPCIONAL)
     .addProp("localidad",THIS._fixStr(THIS.Receptor.DomicilioFiscal.localidad),CFD_OPCIONAL)
     .addProp("referencia",THIS._fixStr(THIS.Receptor.DomicilioFiscal.referencia),CFD_OPCIONAL)
     .addProp("municipio",THIS._fixStr(THIS.Receptor.DomicilioFiscal.municipio),CFD_OPCIONAL)
     .addProp("estado",THIS._fixStr(THIS.Receptor.DomicilioFiscal.estado),CFD_OPCIONAL)
     .addProp("pais",THIS._fixStr(THIS.Receptor.DomicilioFiscal.pais))
     .addProp("codigoPostal",THIS._fixStr(THIS.Receptor.DomicilioFiscal.codigoPostal),CFD_OPCIONAL)
    ENDWITH
   ENDWITH
   
   
   *-- Nodo "Conceptos"
   *   
   *   La clase XmlParser no reconoce que un nodo pueda contener dos subnodos con el mismo nombre. Para
   *   solucionar este impase, se le anade un contador al nombre de cada nodo Concepto, de modo que quede 
   *   asi:
   *
   *   <Conceptos>
   *     <Concepto001 ... />
   *     <Concepto002 ... />
   *   </Conceptos>
   *
   *   Una vez generado el Xml, se cargara en memoria para quitar las secuencias y asi corregir el problema
   *
   *   VES Nov 11, 2011
   *   La nueva propiedad createNodeLinks en la clas XMLNodeClass permite superar este problema
   *
   LOCAL i,oItem,oNodo
   .XML._Comprobante.addNode("Conceptos")
   WITH .XML._Comprobante._Conceptos
    .createNodeLinks = .F.   && Nov 11, 2011
    FOR i = 1 TO THIS.Conceptos.Count
     oItem = THIS.Conceptos.Items(i)
     oNodo = .addNode("Concepto")
     WITH oNodo
      .addProp("cantidad",THIS._fixStr(STR(oItem.cantidad,10,3)))
      .addProp("unidad",THIS._fixStr(oItem.unidad),CFD_OPCIONAL)
      .addProp("noIdentificacion",THIS._fixStr(oItem.noIdentificacion),CFD_OPCIONAL)
      .addProp("descripcion",THIS._fixStr(oItem.descripcion))
      .addProp("valorUnitario",THIS._fixStr(STR(oItem.valorUnitario,15,2)))
      .addProp("importe",THIS._fixStr(STR(oItem.Importe,15,2)))
      
      IF !EMPTY(oItem.informacionAduanera.Numero)
       .addNode("InformacionAduanera")
       WITH .Nodes[1]  && VES Nov 11, 2011
        .addProp("numero",THIS._fixStr(oItem.informacionAduanera.numero))
        .addProp("fecha",THIS._fixStr(oItem.informacionAduanera.fecha))        
        .addProp("aduana",THIS._fixStr(oItem.informacionAduanera.aduana))        
       ENDWITH
      ENDIF

      IF !EMPTY(oItem.CuentaPredial.Numero)
       .addNode("CuentaPredial")
       WITH ._CuentaPredial
        .addProp("numero",THIS._fixStr(oItem.CuentaPredial.numero))
       ENDWITH
      ENDIF
      
     ENDWITH
    ENDFOR
   ENDWITH
   
   
   *-- Nodo "Impuestos"
   *
   *   Tanto para los subnodos de Retenciones como de Impuestos se aplico la misma tecnica de enumeracion
   *   aplicada con los subnodos de Conceptos
   *
   *   VES Nov 11, 2011
   *   Se aplica la nueva propiedad createNodeLinks para evitar este problema
   *
   .XML._Comprobante.addNode("Impuestos")
   WITH .XML._Comprobante._Impuestos
    IF THIS.Impuestos.Retenciones.Count > 0
     .addProp("totalImpuestosRetenidos",THIS._fixStr(STR(THIS.Impuestos.totalImpuestosRetenidos,15,2)))
     .addNode("Retenciones")
     WITH ._Retenciones
     .createNodeLinks = .F.   && Nov 11, 2011     
      FOR i = 1 TO THIS.Impuestos.Retenciones.Count
       oItem = THIS.Impuestos.Retenciones.Items(i)
       oNodo = .addNode("Retencion")
       oNodo.addProp("impuesto",THIS._fixStr(oItem.Impuesto))
       oNodo.addProp("importe",THIS._fixStr(STR(oItem.Importe,15,2)))
      ENDFOR
     ENDWITH
    ENDIF
    
    IF THIS.Impuestos.Traslados.Count > 0
     .addProp("totalImpuestosTrasladados",THIS._fixStr(STR(THIS.Impuestos.totalImpuestosTrasladados,15,2))) 
     .addNode("Traslados")
     WITH ._Traslados
      .createNodeLinks = .F.  && Nov 11, 2011
      FOR i = 1 TO THIS.Impuestos.Traslados.Count
       oItem = THIS.Impuestos.Traslados.Items(i)
       oNodo = .addNode("Traslado")
       oNodo.addProp("impuesto",THIS._fixStr(oItem.Impuesto))
       oNodo.addProp("tasa",THIS._fixStr(STR(oItem.tasa,6,2)))       
       oNodo.addProp("importe",THIS._fixStr(STR(oItem.Importe,15,2)))
      ENDFOR
     ENDWITH
    ENDIF
    
   ENDWITH



   *-- Nodo "Addenda"
   *
   *   VES Nov 14, 2011
   *   Se reprogramo esta rutina para hacer uso de la nueva clase ICFDAddenda
   *
   IF !ISNULL(THIS.Addenda) AND LOWER(THIS.Addenda.ParentClass) == "icfdaddenda"
    oNodo = oParser.XML._Comprobante.addNode(THIS.Addenda.nodeName)
    oNodo.Data = THIS.Addenda.ToString() 
    IF !EMPTY(THIS.Addenda.NSTag)
     oParser.XML._Comprobante.addProp("xmlns:" + THIS.Addenda.NSTag, THIS.Addenda.NSUrl)
    ENDIF
    IF !EMPTY(THIS.Addenda.schemaLocation)
     WITH oParser.XML._Comprobante.Props["xsi:schemaLocation"]
      .Value = .Value + SPACE(1) + THIS.Addenda.schemaLocation
     ENDWITH
    ENDIF
   ENDIF 

   

   *-- Se crea el archivo Xml
   .Save(pcArchivo)
   
   
   *-- Se carga el Xml en memoria de nuevo para eliminar los tags consecutivos
   *   de los nodos Concepto, Retenciones y Traslados, asi como eliminar los
   *   CRLF
   LOCAL cBuff
   cBuff = FILETOSTR(pcArchivo)
*!*	   FOR i = 1 TO THIS.Conceptos.Count
*!*	    cBuff = STRT(cBuff,"<Concepto" + PADL(i,3,"0"),"<Concepto")
*!*	    cBuff = STRT(cBuff,"</Concepto" + PADL(i,3,"0"),"</Concepto")    
*!*	   ENDFOR
*!*	   FOR i = 1 TO THIS.Impuestos.Retenciones.Count
*!*	    cBuff = STRT(cBuff,"<Retencion" + PADL(i,2,"0"),"<Retencion")
*!*	   ENDFOR
*!*	   FOR i = 1 TO THIS.Impuestos.Traslados.Count
*!*	    cBuff = STRT(cBuff,"<Traslado" + PADL(i,2,"0"),"<Traslado")
*!*	   ENDFOR
   cBuff = STRT(cBuff, ">" + CHR(13)+CHR(10), ">")
   cBuff = STRT(cBuff, "?>", "?>" + CHR(13) + CHR(10))
   
   
   *-- Si es CFDI se agrega a los nodos el prefijo 'cfdi:'
   *
   *   VES Nov 11, 2011
   *   Solucionado con la nueva propiedad NameSpace de la clase XMLNodeClass
   *
*!*	   IF ALLTRIM(THIS.version) = "3.0"
*!*		cBuff = STRT(cBuff, "<Comprobante", "<cfdi:Comprobante")	   
*!*			cBuff = STRT(cBuff, "<Emisor", "<cfdi:Emisor")
*!*				cBuff = STRT(cBuff, "<DomicilioFiscal", "<cfdi:DomicilioFiscal")
*!*				cBuff = STRT(cBuff, "<ExpedidoEn", "<cfdi:ExpedidoEn")
*!*			cBuff = STRT(cBuff, "</Emisor>", "</cfdi:Emisor>")
*!*			cBuff = STRT(cBuff, "<Receptor", "<cfdi:Receptor")
*!*				cBuff = STRT(cBuff, "<Domicilio", "<cfdi:Domicilio")
*!*			cBuff = STRT(cBuff, "</Receptor>", "</cfdi:Receptor>")
*!*			cBuff = STRT(cBuff, "<Conceptos>", "<cfdi:Conceptos>")
*!*				cBuff = STRT(cBuff, "<Concepto ", "<cfdi:Concepto ")
*!*					cBuff = STRT(cBuff, "<InformacionAduanera", "<cfdi:InformacionAduanera")
*!*					cBuff = STRT(cBuff, "<CuentaPredial", "<cfdi:CuentaPredial")
*!*					cBuff = STRT(cBuff, "<ComplementoConcepto", "<cfdi:ComplementoConcepto")
*!*					cBuff = STRT(cBuff, "<Parte", "<cfdi:Parte")
*!*				cBuff = STRT(cBuff, "</Concepto>", "</cfdi:Concepto>")
*!*			cBuff = STRT(cBuff, "</Conceptos>", "</cfdi:Conceptos>")
*!*			cBuff = STRT(cBuff, "<Impuestos", "<cfdi:Impuestos")
*!*				cBuff = STRT(cBuff, "<Retenciones>", "<cfdi:Retenciones>")
*!*					cBuff = STRT(cBuff, "<Retencion", "<cfdi:Retencion")
*!*				cBuff = STRT(cBuff, "</Retenciones>", "</cfdi:Retenciones>")
*!*				cBuff = STRT(cBuff, "<Traslados>", "<cfdi:Traslados>")
*!*					cBuff = STRT(cBuff, "<Traslado", "<cfdi:Traslado")
*!*				cBuff = STRT(cBuff, "</Traslados>", "</cfdi:Traslados>")
*!*			cBuff = STRT(cBuff, "</Impuestos>", "</cfdi:Impuestos>")
*!*			cBuff = STRT(cBuff, "<Addenda>", "<cfdi:Addenda>")
*!*		cBuff = STRT(cBuff, "</Comprobante>", "</cfdi:Comprobante>")
*!*	   ENDIF 
   
   
   *-- Se graba de nuevo el Xml ya en su forma final
   cBuff = CFDAsc2UTF8(cBuff)
   
   *-- El 4 del tercer parámetro en STRTOFILE() agrega el BOM al XML en UTF-8
   IF CFDConf.incluirBOM
      STRTOFILE(cBuff,pcArchivo,4)
   ELSE 
      STRTOFILE(cBuff,pcArchivo)
   ENDIF 
   cBuff=""
   
   
   *-- Si se indico el parametro plValidar, se verifica que el XML este bien formado y que el sello sea valido
   *
   IF plValidar
    *
    *-- Se valida la sintaxis del XML
    IF NOT CFDValidarXML(pcArchivo, pcArchivoKey, pcPassword, pcMetodo, THIS.ubicacionOpenSSL)
     RETURN .F.
    ENDIF
    *
   ENDIF
   
   
   RETURN .T.
   *
  ENDWITH 
  
  *
 ENDPROC
 *

ENDDEFINE



*-- CFDPersona (Clase)
*   Representa los datos de una persona juridica especifica
*   dentro de un comprobante digital
*
DEFINE CLASS CFDPersona AS Custom
 *
 *-- Atributos requeridos
 RFC = ""
 Nombre = ""
 domicilioFiscal = NULL
 
 *-- Atributos opcionales
 expedidoEn = NULL
 
 
 *-- Contructor de la clase
 PROCEDURE Init
  THIS.domicilioFiscal = CREATEOBJECT("CFDDireccion")
  THIS.expedidoEn = CREATEOBJECT("CFDDireccion")  
 ENDPROC
 *
ENDDEFINE



*-- CFDDireccion (Clase)
*   Representa una direccion fiscal dentro de un
*   comprobante digital
*
DEFINE CLASS CFDDireccion AS Custom
 *
 *-- Atributos requeridos
 Calle = ""
 Municipio = ""
 Estado = ""
 Pais = ""
 codigoPostal = ""

 *-- Atributos opcionales 
 noExterior = ""
 noInterior = ""
 Colonia = ""
 Localidad = ""
 Referencia = ""
 *
ENDDEFINE


*-- CFDConceptos (Clase)
*   Representa la lista de conceptos contenidos en el comprobante
*
DEFINE CLASS CFDConceptos AS CFDCollection
 *
 *-- Add (Metodo)
 *   Incluye un nuevo elemento en la coleccion
 *
 PROCEDURE Add(pnCantidad, pcDescripcion, pnPU, pnImporte)
  *
  LOCAL oConcepto
  oConcepto = CREATEOBJECT("CFDConcepto")
  WITH oConcepto
   .Cantidad = pnCantidad
   .Descripcion = pcDescripcion
   .valorUnitario = pnPU
   .Importe = pnImporte
  ENDWITH
  
  RETURN DODEFAULT(oConcepto)
  *
 ENDPROC
 *
ENDDEFINE



*-- CFDConcepto (Clase)
*   Representa una linea de la factura dentro de un comprobante digital
*
DEFINE CLASS CFDConcepto AS Custom
 *
 *-- Atributos requeridos
 Cantidad = 0.00
 Descripcion = ""
 valorUnitario = 0.00
 Importe = 0.00
 
 
 *-- Atributos opcionales
 noIdentificacion = ""
 informacionAduanera = NULL
 cuentaPredial = NULL
 Unidad = ""


 *-- Constructor de la clase
 PROCEDURE Init
  THIS.informacionAduanera = CREATEOBJECT("CFDInformacionAduanera")
  THIS.cuentaPredial = CREATEOBJECT("CFDCuentaPredial")
 ENDPROC 
 *
ENDDEFINE



*-- CFDInformacionAduanera (Clase)
*   Representa la informacion de aduana de un concepto especifico
*
DEFINE CLASS CFDInformacionAduanera AS Custom
 *
 *-- Atributos obligatorios
 Numero = ""
 Fecha = {}
 Aduana = ""
 
 *-- Atributos opcionales
 *
ENDDEFINE



*-- CFDCuentaPredial (Clase)
*   Representa la informacion de la cuenta predial asociada a un concepto (aplica
*   principalmente a inmuebles).
*
DEFINE CLASS CFDCuentaPredial AS Custom
 *
 *-- Atributos obligatorios 
 Numero = ""
 
 *-- Atributos opcionales 
 *
ENDDEFINE



*-- CFDImpuestos (Clase)
*   Representa los datos de impuestos del comprobante
*
DEFINE CLASS CFDImpuestos AS Custom
 *
 *-- Atributos obligatorios 
  
 
 *-- Atributos opcionales 
 totalImpuestosRetenidos = 0.00  && Solo lectura
 totalImpuestosTrasladados = 0.00  && Solo lectura
 Retenciones = NULL
 Traslados = NULL
 
 
 *-- Getters / Setters
 PROCEDURE totalImpuestosRetenidos_Access
  *
  LOCAL i, nTotal
  nTotal = 0.00
  FOR i = 1 TO THIS.Retenciones.Count
   nTotal = nTotal + THIS.Retenciones.Items(i).Importe
  ENDFOR
  
  RETURN nTotal
  *
 ENDPROC
 PROCEDURE totalImpuestosRetenidos_Assign(vNewVal)
 ENDPROC
 
 PROCEDURE totalImpuestosTrasladados_Access
  *
  LOCAL i, nTotal
  nTotal = 0.00
  FOR i = 1 TO THIS.Traslados.Count
   nTotal = nTotal + THIS.Traslados.Items(i).Importe
  ENDFOR
  
  RETURN nTotal
  *
 ENDPROC
 PROCEDURE totalImpuestosTrasladados_Assign(vNewVal)
 ENDPROC

 
 *-- Constructor de la clase
 PROCEDURE Init
  THIS.Retenciones = CREATEOBJECT("CFDRetenciones")
  THIS.Traslados = CREATEOBJECT("CFDTraslados")
 ENDPROC
 *
ENDDEFINE



*-- CFDRetenciones (Clase)
*   Representa la lista de retenciones de impuestos del comprobante
*
DEFINE CLASS CFDRetenciones AS CFDCollection
 *
 *-- Add (Metodo)
 *   Incluye una nueva retencion en la lista
 *
 PROCEDURE Add(pcImpuesto, pnImporte)
  *
  LOCAL oRetencion
  oRetencion = CREATEOBJECT("CFDRetencion")
  WITH oRetencion
   .Impuesto = pcImpuesto
   .Importe = pnImporte
  ENDWITH
  
  RETURN DODEFAULT(oRetencion)
  *
 ENDPROC
 *
ENDDEFINE



*-- CFDTraslados (Clase)
*   Representa la lista de impuestos trasladados del comprobante
*
DEFINE CLASS CFDTraslados AS CFDCollection
 *
 *-- Add (Metodo)
 *   Incluye un nuevo traslado en la lista
 *
 PROCEDURE Add(pcImpuesto, pnTasa, pnImporte)
  *
  LOCAL oTraslado
  oTraslado = CREATEOBJECT("CFDTraslado")
  WITH oTraslado
   .Impuesto = pcImpuesto
   .Tasa = pnTasa
   .Importe = pnImporte
  ENDWITH
  
  RETURN DODEFAULT(oTraslado)
  *
 ENDPROC
 *
ENDDEFINE



*-- CFDRetencion (Clase)
*   Representa los datos de una retencion de impuestos
*
DEFINE CLASS CFDRetencion AS Custom
 *
 *-- Atributos obligatorios 
 Impuesto = ""
 Importe = 0.00
 
 *-- Atributos opcionales 
 *
ENDDEFINE



*-- CFDTraslado (Clase)
*   Representa los datos de un impuesto trasladado
*
DEFINE CLASS CFDTraslado AS Custom
 *
 *-- Atributos obligatorios 
 Impuesto = ""
 Tasa = 0.00
 Importe = 0.00
 
 *-- Atributos opcionales 
 *
ENDDEFINE



*-- CFDAddenda (Clase)
*   Representa una lista de pares (nombre, valor) que representa datos
*   adicionales a ser incluidos en la seccion Addenda del comprobante
*
*   VES Nov 12, 2011
*   A partir de la version 3.4, esta clase se queda obsoleta y ya no 
*   tiene efecto cobre el CFD. En su lugar, debe usarse la interfaz
*   ICFDAddenda y las propiedades Addenda y Complemento de la clase
*   CFDComprobante.
*
DEFINE CLASS CFDAddenda AS CFDCollection
 *
 *-- Add (Metodo)
 *   Incluye un nuevo elemento en la lista de addendas (se mantiene por
 *   compatibilidad con versiones anteriores)
 *
 PROCEDURE Add(pcNombre, pcValor)
  *
  LOCAL oItem
  oItem = CREATEOBJECT("Custom")
  oItem.addProperty("Nombre",pcNombre)
  oItem.addProperty("Valor",pcValor)
  
  DODEFAULT(oItem)
  *
 ENDPROC
 *
ENDDEFINE



*-- CFDCollection (Clase)
*   Representa una coleccion de elementos
*
DEFINE CLASS CFDCollection AS Custom


	HIDDEN ncount
	ncount = 0
	HIDDEN leoc
	leoc = .T.
	HIDDEN lboc
	lboc = .T.
	*-- Indica la posición actual dentro de la colección
	listindex = 0
	*-- Nombre de la clase a instanciar al llamar al método New.
	newitemclass = ""
	Name = "cbasiccollection"

	*-- Nro. de elementos en la colección
	count = .F.

	*-- Indica si se ha llegado al final de la colección
	eoc = .F.

	*-- Indica si se ha llegado al tope de la colección.
	boc = .F.

	*-- Devuelve el valor actual en la colección
	current = .F.

	*-- Lista de elementos en la colección
	DIMENSION items[1,1]
	PROTECTED aitems[1,1]


	PROCEDURE items_access
		LPARAMETERS m.nIndex1, m.nIndex2

		if type("m.nIndex1")="C"
		 m.nIndex1=this.FindItem(m.nIndex1)
		endif

		RETURN THIS.aItems[m.nIndex1]
	ENDPROC


	PROCEDURE items_assign
		LPARAMETERS vNewVal, m.nIndex1, m.nIndex2

		if type("m.nIndex1")="C"
		 m.nIndex1=this.FindItem(m.nIndex1)
		endif

		if between(m.nIndex1,1,THIS.Count)
		 THIS.aItems[m.nIndex1]=m.vNewVal
		endif
	ENDPROC


	PROCEDURE count_access

		RETURN THIS.nCount
	ENDPROC


	PROCEDURE count_assign
		LPARAMETERS vNewVal
	ENDPROC


	*-- Añade un elemento a la colección
	PROCEDURE add
		lparameters puValue

		if parameters()=0
		 return .F.
		endif

		this.nCount=this.nCount + 1
		dimen this.aItems[this.nCount]
		this.aItems[this.nCount]=puValue
		this.lEOC=.F.
		this.lBOC=.F.

		if this.ListIndex=0
		 this.ListIndex=1
		endif

		return puValue
	ENDPROC


	*-- Elimina un elemento de la colección
	PROCEDURE remove
		lparameters puValue

		if parameters()=0 
		 return .F.
		endif

		local nIndex
		nIndex=this.FindItem(puValue)
		if nIndex > 0
		 return this.RemoveItem(nIndex)
		else
		 return .F.
		endif
	ENDPROC


	*-- Limpia la colección
	PROCEDURE clear
		local i,uItem
		for i=1 to this.nCount
		 uItem=this.aItems[i]
		 if type("uItem")="O"
		  release uItem
		  this.aItems[i]=NULL
		 endif
		endfor

		dimen this.aItems[1]
		this.aItems[1]=NULL
		this.nCount=0
		this.lBOC=.T.
		this.lEOC=.T.
		this.ListIndex=0
	ENDPROC


	*-- Determina si un elemento dado forma parte de la colección.
	PROCEDURE isitem
		lparameters puValue,pcSearchProp

		if parameters()=0
		 return .F.
		endif

		return (this.FindItem(puValue,pcSearchProp)<>0)
	ENDPROC


	*-- Devuelve la posición en la colección donde se encuentra el elemento indicado
	PROCEDURE finditem
		lparameters puValue,pcSearchProp


		if parameters()=0 or this.nCount=0
		 return 0
		endif

		if vartype(pcSearchProp)<>"C"
		 pcSearchProp=""
		endif

		local i,uItem,cType1,nPos
		nPos=0
		cType1=type("puValue")
		for i=1 to this.nCount
		 uItem=this.aItems[i]
		 if type("uItem")="O" 
		  if (cType1="O" and type("uItem.Name")="C" and type("puVale.Name")="C" and upper(uItem.Name)==upper(puValue.Name)) or ;
		     (cType1="C" and type("uItem.Name")="C" and upper(uItem.Name)==upper(puValue)) or ;
		     (cType1<>"O" and not empty(pcSearchProp) and type("uItem."+pcSearchProp)=cType1 and eval("uItem."+pcSearchProp)==puValue)
		   nPos=i
		   exit
		  endif 
		 else
		  if type("uItem")=cType1 and ((cType1<>"C" and uItem=puValue) or (cType1="C" and uItem==puValue))
		   nPos=i
		   exit
		  endif
		 endif
		endfor

		return nPos
	ENDPROC


	*-- Elimina un item por su posición
	PROCEDURE removeitem
		LPARAMETERS nIndex

		if parameters()=0 or not between(nIndex,1,this.nCount)
		 return .f.
		endif

		local uItem
		uItem=this.aItems[nIndex]

		if type("uItem")="O"
		 release uItem
		 this.aItems[nIndex]=NULL
		endif

		adel(this.aItems,nIndex)

		this.nCount=this.nCount - 1
		if this.nCount > 0 
		 dimen this.aItems[this.nCount]
		 if this.nCount > this.ListIndex
		  this.ListIndex=this.nCount
		 endif
		else
		 this.aItems[1]=NULL
		 this.lEOC=.T.
		 this.lBOC=.T.
		 this.ListIndex=0
		endif
	ENDPROC


	PROCEDURE eoc_access

		RETURN THIS.lEOC
	ENDPROC


	PROCEDURE eoc_assign
		LPARAMETERS vNewVal
	ENDPROC


	PROCEDURE boc_access

		RETURN THIS.lBOC
	ENDPROC


	PROCEDURE boc_assign
		LPARAMETERS vNewVal
	ENDPROC


	*-- Ir al primer elemento en la colección
	PROCEDURE first
		if this.nCount=0
		 return
		endif

		this.ListIndex=1
		this.lBOC=.F.
		this.lEOC=.F.
	ENDPROC


	*-- Ir al siguiente elemento en la colección
	PROCEDURE next
		if this.nCount=0
		 return
		endif

		if this.ListIndex < this.nCount
		 this.ListIndex=this.ListIndex + 1
		 this.lBOC=.F.
		 this.lEOC=.F.
		else
		 this.lBOC=(this.nCount=1)
		 this.lEOC=.T.
		endif
	ENDPROC


	*-- Ir al último elemento en la colección
	PROCEDURE last
		if this.nCount=0
		 return
		endif

		this.ListIndex=this.nCount
		this.lBOC=.F.
		this.lEOC=.F.
	ENDPROC


	*-- Ir al elemento anterior en la colección
	PROCEDURE previous
		if this.nCount=0
		 return
		endif

		if this.ListIndex > 1
		 this.ListIndex=this.ListIndex - 1
		 this.lBOC=.F.
		 this.lEOC=.F.
		else
		 this.lBOC=.T.
		 this.lEOC=(this.nCount=1) 
		endif
	ENDPROC


	PROCEDURE listindex_assign
		LPARAMETERS vNewVal

		if type("m.vNewVal")="N" and between(m.vNewVal,1,this.nCount)
		 THIS.ListIndex = m.vNewVal
		 THIS.lEOC=.F.
		 this.lBOC=.F.
		endif
	ENDPROC


	PROCEDURE current_access
		if this.ListIndex=0
		 return NULL
		else
		 RETURN THIS.aItems[this.ListIndex]
		endif
	ENDPROC


	PROCEDURE current_assign
		LPARAMETERS vNewVal

		if this.ListIndex > 0
		 THIS.aItems[this.ListIndex]=m.vNewVal
		endif
	ENDPROC


	*-- Crea una instancia de la clase indicada en NewItemClass y devuelve una referencia al mismo.
	PROCEDURE new
		if empty(this.NewItemClass)
		 return NULL
		endif

		local oItem
		oItem=Kernel.CC.New(this.NewItemClass)

		return oItem
	ENDPROC


	*-- Permite añadir un item a la colección, solo si el mismo no existe.
	PROCEDURE addifnew
		lparameters puValue

		if parameters()=0
		 return .F.
		endif

		if not this.IsItem(puValue)
		 this.Add(puValue)
		endif

		return puvalue
	ENDPROC


ENDDEFINE



*-- CFDTraslado (Clase)
*   Representa los datos de un certificado
*
DEFINE CLASS CFDCertificado AS Custom
 *
 Archivo = ""			&& Nombre y ubicacion del archivo .CER
 Valido = .F.			&& Indica si el certificado es valido o no
 Vigente = .F.			&& Indica si el certificado esta vigente o no
 Certificado = ""		&& Contenido del certificado
 Serial = ""			&& Serial del certificado
 VigenteDesde = {//::}	&& Inicio de la vigencia
 vigenteHasta = {//::}	&& Fin de la vigencia
 *
ENDDEFINE


*-- ICFDAddenda (Clase)
*   Interfaz para addendas. Esta clase no debe instanciarse directamente sino servir
*   de base a otras clases mas especializadas, las cuales deben implementar el metodo
*   ToString()
*
DEFINE CLASS ICFDAddenda AS Custom
 *
 nodeName = "Addenda"   && Nombre del nodo: Addenda o Complemento 
 schemaLocation = ""    && Ubicacion del schema
 NSTag = ""             && Tag del NameSpace 
 NSUrl = ""             && Url del XSLT asociado al NameSpace
   
 PROCEDURE ToString()
 ENDPROC
 *
ENDDEFINE






********************************************************
**
**  X M L P A R S E R
**
**  Clase para creacion y lectura de archivos XML 
**  mediante una interfaz OOP.
**
**  Autor: Victor Espina
**
*********************************************************

DEFINE CLASS XmlParser AS custom


	*-- Cadena utilizada para indentar un archivo XML al generarlo (TAB por omisión)
	indentstring = ((CHR(9)))
	Name = "xmlparser"

	*-- Nombre del archivo XML en uso
	filename = .F.

	*-- Apuntador al objeto que contiene la estructura del archivo XML actual
	xml = .F.

    *-- VES Nov 11, 2011: nueva propiedad para controlar si se genera o no
    *   los alias de nodo
    createNodeLinks = .T.


	*-- Prepara un nuevo archivo XML
	PROCEDURE new
		THIS.XML=CREATEOBJECT("XMLNodeClass")
		THIS.XML.Name="ROOT"
		THIS.XML.createNodeLinks = THIS.createNodeLinks  && Nov 11, 2011
		THIS.XML.indentString = THIS.indentString && Nov 11, 2011
		THIS.FileName=""
		  
		RETURN THIS.XML
	ENDPROC


	*-- Abre un archivo XML y lo carga en memoria en la propiedad XML.
	PROCEDURE open
		LPARAMETERS pcFileName


		  *-- Se carga el XML en memoria
		  *
		  LOCAL nPos,cData,nSize
		  LOCAL ARRAY XMLData[1]
		  cData=FILETOSTR(pcFileName)
		  IF ATC("<?XML ",cData)<>0
		   nPos=ATC("?>",cData)
		   cData=SUBS(cData,nPos + 2)
		  ENDIF
		  nSize=ALINES(XMLData,cData)  
		  THIS.FileName=pcFileName


		  *-- Se lee el XML y se carga en forma de objetos
		  *
		  LOCAL i,j,k,cLin,cText,oNode,oParent,nOpenTag,nCloseTag1,nCloseTag2,nCloseTag3
		  LOCAL cProps,cData,lPropMode,lDataMode,lClosedTag,lEndedTag,cName
		  oParent=CREATEOBJECT("XMLNodeClass")
		  oParent.Name="ROOT"
		  
		  FOR i=1 TO nSize
		   *
		   cLin=XMLData[i]
		   nOpenTag=AT("<",cLin)
		   nCloseTag1=AT("</",cLin)
		   nCloseTag2=AT(">",cLin)
		   nCloseTag3=AT("/>",cLin)
		  
		 
		   DO CASE
		      CASE nOpenTag<>0 and (nCloseTag1=0 or nCloseTag1 > nOpenTag)         && Nuevo nodo
		           *-- Se instancia el Nodo
		           oNode=CREATEOBJECT("XMLNodeClass")
		           oNode.cProps=""
		           oNode.cData=""
		           oNode.lPropMode=False
		           oNode.lDataMode=False
		           oNode.createNodeLinks = THIS.createNodeLinks
		           
		      
		           *-- Se aisla de la cadena la parte que corresponde al nombre del nodo
		           *   y una posible lista de propiedades
		           cText=SUBS(cLin,nOpenTag + 1)
		           j=AT("/>",cText)
		           j=IIF(j=0,AT(">",cText),j)
		           lClosedTag=(j<>0)
		           IF lClosedTag
		            cText=LEFT(cText,j - 1)
		           ENDIF
		           
		           *-- Se obtiene el nombre del nodo y se aisla la 
		           *   posible lista de parámetros
		           cName=""
		           j=AT(" ",cText)
		           IF j=0
		            cName=ALLT(cText)
		           ELSE
		            cName=ALLT(LEFT(cText,j - 1))
		            oNode.cProps=SUBS(cText,j + 1)
		            oNode.lPropMode=(NOT lClosedTag)
		           ENDIF
		           
		           IF AT(":",cName) = 0   && Nov 11, 2011
		            oNode.Name=cName
		            oNode.nameSpace = ""
		           ELSE
		            oNode.Name = SUBS(cName,AT(":",cName) + 1)
		            oNode.nameSpace = LEFT(cName,AT(":",cName) - 1)
		           ENDIF 
		           
		          
		           *-- Si hay un nodo padre activo, se añade el nodo a dicho padre
		           IF NOT ISNULL(oParent)
		            oParent.AddNode(oNode)
		           ENDIF
		            
		           
		           *-- Si hay una lista de propiedades y el nodo estaba cerrado
		           *   se carga la lista de propiedades del nodo
		           IF (NOT EMPTY(oNode.cProps)) AND (NOT oNode.lPropMode)
		            THIS.iSplitProps(oNode.cProps,oNode)
		           ENDIF
		           
		           
		           *-- Se aisla la posible DATA del nodo (si el nodo está cerrado)
		           IF lClosedTag AND nCloseTag3=0
		            *
		            cText=SUBS(cLin,nCloseTag2 + 1)
		            
		            *-- Si la linea contiene el fin del nodo, se aisla la DATA y se cierra el nodo
		            *   de lo contrario, se activa la modalidad lDataMode
		            IF nCloseTag1<>0AND OCCURS("</",cText)=1 AND ATC("</"+oNode.Name+">",cText)<>0
		             cText=LEFT(cText,AT("</",cText) - 1)
		             oNode.Data=cText
		             oNode.lDataMode=False
		            ELSE
		             oNode.cData=cText
		             oNode.lDataMode=True
		            ENDIF
		            *
		           ENDIF
		           
		           *-- Si el nodo fué completamente procesado, se retorna el control al nodo
		           *   padre; de lo contrario se asume el nodo actual como nuevo nodo padre
		           IF oNode.lPropMode OR oNode.lDataMode
		            oParent=oNode
		           ELSE
		            IF NOT ISNULL(oNode.ParentNode)
		             oParent=oNode.ParentNode
		            ENDIF 
		           ENDIF
		          
		           
		      CASE ISNULL(oParent)
		           *-- No se requiere acción     
		           
		      CASE oParent.lPropMode AND nCloseTag1=0 AND nCloseTag2=0     && Linea de propiedades sin fin ni cierre de nodo  ( Prop=Valor )
		           oParent.cProps=oParent.cProps + " " + cLin
		           
		      CASE oParent.lPropMode AND nCloseTag1=0 AND nCloseTag2<>0    && Linea de propiedades con cierre de nodo  ( Prop=Valor> )
		           oParent.cProps=oParent.cProps + " " + LEFT(cLin,nCloseTag2 - 1)
		           oParent.lPropMode=False
		           THIS.iSplitProps(oParent.cProps,oParent)

		           cText=SUBS(cLin,nCloseTag2+1)
		           oNode.cData=cText
		           oNode.lDataMode=True
		                        
		      CASE oParent.lPropMode AND nCloseTag1<>0 AND nCloseTag2<>0   && Linea de propiedades con fin de nodo   ( Prop=Valor> </nodo>)
		           oParent.cProps=oParent.cProps + " " + LEFT(cLin,nCloseTag2 - 1)
		           oParent.lPropMode=False
		           THIS.iSplitProps(oParent.cProps,oParent)
		           
		           cText=SUBS(cLin,nCloseTag2+1)
		           cText=SUBS(cText,AT("</",cText) - 1)
		           oNode.cData=cText

		           *-- Se retorna el control al nodo padre
		           IF NOT ISNULL(oParent.ParentNode)
		            oParent=oParent.ParentNode
		           ENDIF 

		           
		      CASE oParent.lDataMode AND nCloseTag1=0    && Linea de datos sin fin de nodo ( data )
		           oParent.cData=oParent.cData + IIF(EMPTY(oParent.cData),"",CRLF) + cLin
		           
		      CASE oParent.lDataMode AND nCloseTag1<>0   && Linea de datos con fin de modo ( data </nodo> )
		           oParent.cData=oParent.cData + IIF(EMPTY(oParent.cData),"",CRLF) + LEFT(cLin,nCloseTag1 - 1)
		           oParent.Data=oParent.cData     
		           oParent.lDataMode=False

		           *-- Se retorna el control al nodo padre
		           IF NOT ISNULL(oParent.ParentNode)
		            oParent=oParent.ParentNode
		           ENDIF 
		           
		           
		      OTHERWISE
		           *-- Se obvia la linea                
		   ENDCASE
		   *
		  ENDFOR
		  
		  THIS.XML=oParent
		  
		  RETURN THIS.XML
	ENDPROC


	*-- Genera un archivo XML en base a los datos cargados en memoria
	PROCEDURE save
		LPARAMETERS pcFileName

		  IF VARTYPE(pcFileName)="C"
		   THIS.FileName=pcFileName
		  ENDIF
		  IF EMPTY(THIS.FileName)
		   RETURN False
		  ENDIF
		  
		  SET TEXTMERGE TO (THIS.FileName) NOSHOW
		  SET TEXTMERGE ON
		  \\<?xml version="1.0" encoding="UTF-8"?>
		  LOCAL i
		  FOR i=1 TO THIS.XML.NodeCount
		   THIS.iSaveNode(THIS.XML.Nodes(i))
		  ENDFOR 
		  SET TEXTMERGE OFF
		  SET TEXTMERGE TO
	ENDPROC


	*-- Genera un string con el XML
	PROCEDURE ToString()
		LPARAMETERS pnMargin
          LOCAL cXML,cCRLF,i
          cCRLF = CHR(13)+CHR(10)
          cXML = ""
          FOR i = 1 TO THIS.XML.NodeCount
           IF i > 1
            cXML = cXML + cCRLF
           ENDIF
           cXML = cXML + THIS.XML.Nodes[i].ToString(pnMargin)
          ENDFOR
		  RETURN cXML
	ENDPROC


	*-- Salva un nodo del XML
	HIDDEN PROCEDURE isavenode
		LPARAMETERS poNode,pnMargin

		  LOCAL nDeep,cAlign,i,uValue
		  nDeep=OCCURS("\",poNode.FullPath) 
		  cAlign=REPL(THIS.IndentString,nDeep)
		  IF CFDEVL(pnMargin,0) > 0
		   cAlign = REPL(THIS.indentString,pnMargin) + cAlign
		  ENDIF
		  
		  \<<cAlign>><<"<"+poNode.nodeName>>
		  
		  FOR i=1 TO poNode.PropCount
		   IF i=1
		    \\<<space(1)>>
		   ENDIF
		   uValue=poNode.Props(i).Value
		   DO CASE
		      CASE VARTYPE(uValue)="C"
		           uValue=["]+uValue+["]
		      CASE VARTYPE(uValue)="D"
		           uValue=[{]+DTOC(uValue)+[}]
		      CASE VARTYPE(uValue)="T"
		           uValue=[{]+TTOC(uValue)+[}]
		      CASE VARTYPE(uValue)="N" AND INT(uValue)<>uValue
		           uValue=ALLT(STR(uValue,30,6))
		      CASE VARTYPE(uValue)="N" AND INT(uValue)=uValue
		           uValue=ALLT(STR(uValue,30))
		      CASE VARTYPE(uValue)="L"
		           uValue=IIF(uValue,".T.",".F.")
		      OTHERWISE
		            uValue=TRANS(uValue,"")
		   ENDCASE
		   \\<<poNode.Props(i).Id>>=<<uValue>>
		   IF i < poNode.PropCount
		    \\<<space(1)>>
		    *\<<cAlign+SPACE(5)>>
		   ENDIF
		  ENDFOR

		  IF poNode.PropCount=0 AND poNode.NodeCount=0
		   *
		   IF ISNULL(poNode.Data)
		    \\<<"/>">>
		   ELSE
		    \\<<">">><<poNode.Data>><<+"</"+poNode.nodeName+">">>
		   ENDIF
		   *
		  ELSE          
		   *
		   IF poNode.NodeCount=0
		    IF ISNULL(poNode.Data)
		     \\/>
		    ELSE
		     \\><<poNode.Data>><<"</"+poNode.Id+">">>
		    ENDIF    
		   ELSE
		    IF ISNULL(poNode.Data)
		     \\>
		    ELSE
		     \\><<poNode.Data>>
		    ENDIF    
		    FOR i=1 TO poNode.NodeCount
		     THIS.iSaveNode(poNode.Nodes(i), pnMargin)
		    ENDFOR 
		    \<<cAlign>><<"</"+poNode.nodeNAme+">">>
		   ENDIF 
		   *
		  ENDIF         
	ENDPROC


	*-- Lee una linea de propiedades dada y la convierte en propiedades de un objeto XMLNodeClass dado.
	HIDDEN PROCEDURE isplitprops
		LPARAMETERS pcParamLine,poNode

		 
		  *-- Se recorre la cadena pcParamLine para cambiar los caracteres "=" que no esten
		  *   encerrados en algun "bloque" (ej: (..=..), '..=..', "..=..") por el car. "|". Esto 
		  *   permitirá identificar apropiadamente los pares PROP=VALUE que esten contenidos
		  *   en la cadena pcTagOptions.
		  *   
		  local i,nCount,nBlockDeepth,cChar,lQuoted,lDoubleQuoted
		  nCount=len(pcParamLine)
		  nBlockDeepth=0
		  lQuoted=.F.
		  lDoubleQuoted=.F.
		  for i=1 to nCount
		   cChar=subs(pcParamLine,i,1)
		   do case
		      case inlist(cChar,"(","{","[")
		           nBlockDeepth=nBlockDeepth + 1

		      case inlist(cChar,")","}","]") and nBlockDeepth > 0
		           nBlockDeepth=nBlockDeepth - 1
		          
		      case cChar $ ["]
		           lDoubleQuoted=(NOT lDoubleQuoted)

		      case cChar $ [']
		           lQuoted=(NOT lQuoted)
		          
		      case cChar="=" and nBlockDeepth <= 0 and (not lQuoted) and not (lDoubleQuoted)
		           pcParamLine=stuff(pcParamLine,i,1,"|")
		          
		      case cChar="=" and nBlockDeepth > 0 or lQuoted or lDoubleQuoted
		           * Nothing
		   endcase         
		  endfor


		  *-- Se procesan todas las apariciones del caracter "|"
		  *
		  local cProp,cValue,nPos,cData,j,oProp
		  cData=pcParamLine
		  nCount=occurs("|",cData)
		  for i=1 to nCount
		   *
		   nPos=at("|",cData)
		   cProp=allt(left(cData,nPos - 1))
		   cValue=subs(cData,nPos + 1)
		  
		   if i < nCount
		    nPos=at("|",cValue)
		    j=nPos - 1
		    do while j>1 and not empty(subs(cValue,j,1))
		     j=j - 1
		    enddo
		    if j>1
		     cData=subs(cValue,j+1)
		     cValue=allt(left(cValue,j))
		    endif
		   endif 

		   poNode.AddProp(cProp,EVAL(cValue))  
		   *
		  endfor
	ENDPROC



ENDDEFINE


DEFINE CLASS XmlNodeClass AS custom


	*-- Data asociada al nodo (texto entre  los tags <nodo> y </nodo>)
	data = .NULL.
	*-- Apuntador al nodo padre
	parentnode = .NULL.
	*-- Nro. de propiedades en el nodo
	propcount = 0
	*-- Nro. de subnodos en el nodo
	nodecount = 0
	HIDDEN npropcount
	npropcount = 0
	HIDDEN nnodecount
	nnodecount = 0
	cprops = ""
	cdata = ""
	*-- Ruta completa de acceso al nodo actual.
	fullpath = ""
	Name = "xmlnodeclass"
	lpropmode = .F.
	ldatamode = .F.
	NameSpace = ""  && Nov 11, 2011
	NodeName = "" && Nov 11, 2011
	createNodeLinks = .T.  && Nov 11,2011
	indentString = "" && Nov 11, 2011
	

	*-- Colección de propiedades del nodo
	DIMENSION props[1,1]

	*-- Colección de subnodos del nodo
	DIMENSION nodes[1,1]


	HIDDEN PROCEDURE propcount_access
		RETURN THIS.npropcount
	ENDPROC


	HIDDEN PROCEDURE propcount_assign
		LPARAMETERS vNewVal
	ENDPROC


	HIDDEN PROCEDURE nodecount_access
		RETURN THIS.nnodecount
	ENDPROC


	HIDDEN PROCEDURE nodecount_assign
		LPARAMETERS vNewVal
	ENDPROC


	HIDDEN PROCEDURE props_access
		LPARAMETERS puIndex

		  IF THIS.PropCount=0
		   RETURN NULL
		  ENDIF
		  IF VARTYPE(puIndex)="N"
		   RETURN THIS.Props[puIndex]
		  ELSE
		   RETURN THIS.Props[THIS.FindProp(puIndex)]
		  ENDIF
	ENDPROC


	HIDDEN PROCEDURE nodes_access
		LPARAMETERS puIndex

		  IF THIS.NodeCount=0
		   RETURN NULL
		  ENDIF
		  
		  LOCAL nIndex,i
		  IF TYPE("puIndex")="N"
		   nIndex=puIndex
		  ELSE
		   *
		   IF atc("\",puIndex)=0
		    nIndex=THIS.FindNode(puIndex)
		   ELSE
		    nIndex=THIS.GetNode(puIndex)
		   ENDIF
		   *
		  ENDIF
		  

		  RETURN THIS.Nodes[nIndex]
	ENDPROC

	HIDDEN PROCEDURE nodeName_access
		RETURN IIF(EMPTY(THIS.nameSpace),"",THIS.nameSpace + ":") + THIS.Name
	ENDPROC


	HIDDEN PROCEDURE nodeName_assign
		LPARAMETERS vNewVal
	ENDPROC


	*-- Devuelve la posición dentro de la colección Props[...] para una propiedad dada.
	PROCEDURE findprop
		LPARAMETERS pcPropName

		  LOCAL i,nIndex
		  nIndex=0
		  FOR i=1 TO THIS.PropCount
		   IF UPPER(ALLT(THIS.Props[i].Id))==UPPER(ALLT(pcPropName))
		    nIndex=i
		    EXIT
		   ENDIF
		  ENDFOR
		  
		  RETURN nIndex
	ENDPROC


	*-- Determina si una propiedad dada existe en el nodo o no.
	PROCEDURE isprop
		LPARAMETERS pcPropName

		RETURN (THIS.FindProp(pcPropName)<>0)
	ENDPROC


	*-- Añade una nueva propiedad al nodo.
	PROCEDURE addprop
		LPARAMETERS pcName,puValue,plOptional

          IF EMPTY(puValue) AND plOptional
           RETURN NULL
          ENDIF
           
		  LOCAL oProp,nCount,i
		  LOCAL ARRAY aProps[1]
		  nCount=ALINES(aProps,STRT(pcName,",",CRLF))
		  
		  FOR i=1 TO nCount
		   oProp=CREATEOBJECT("XMLPropClass")
		   oProp.ID=aProps[i]
		   oProp.Value=puValue
		   THIS.nPropCount=THIS.nPropCount + 1
		   DIMENSION THIS.Props[THIS.nPropCount]
		   THIS.Props[THIS.nPropCount]=oProp
		  ENDFOR 
		  
		  RETURN oProp
	ENDPROC


	*-- Elimina una propiedad del nodo
	PROCEDURE removeprop
		LPARAMETERS puIndex

		  IF VARTYPE(puIndex)="C"
		   puIndex=THIS.FindProp(puIndex)
		  ENDIF
		  IF BETWEEN(puIndex,1,THIS.nPropCount)
		   THIS.Props[puIndex]=NULL
		   ADEL(THIS.Props,puIndex)
		   THIS.nPropCount=THIS.nPropCount - 1
		  ENDIF
	ENDPROC


	*-- Permite actualizar el valor de las propiedades del nodo en base a las propiedades del mismo nombre de otro objeto dado.
	PROCEDURE copypropsfrom
		LPARAMETERS poData

		  LOCAL i,cProp
		  FOR i=1 TO THIS.PropCount
		   cProp=THIS.Props(i).Id
		   IF TYPE("poData."+cProp)<>"U"
		    THIS.Props(cProp).Value=EVAL("poData."+cProp)
		   ENDIF
		  ENDFOR
		  
	ENDPROC


	*-- Devuelve una referencia al objeto XMLNodeClass que representa a un nodo dado.
	PROCEDURE getnode
		LPARAMETERS pcNodeFullPath

		  LOCAL ARRAY aNodes[1]
		  LOCAL i,nCount,nIndex
		  nCount=ALINES(aNodes,STRT(pcNodeFullPath,"\",CRLF))
		  oNode=THIS
		  FOR i=1 TO nCount
		   IF UPPER(aNodes[i])==UPPER(THIS.Name)
		    LOOP
		   ENDIF
		   nIndex=oNode.FindNode(aNodes[i])
		   IF nIndex=0
		    EXIT
		   ENDIF
		   oNode=oNode.Nodes(nIndex)
		  ENDFOR
		  
		  RETURN oNode
	ENDPROC


	*-- Devuelve la posición dentro de la colección Nodes[...]  para un nodo indicado.
	PROCEDURE findnode
		LPARAMETERS pcNodeName

		  LOCAL i,nIndex
		  nIndex=0
		  FOR i=1 TO THIS.NodeCount
		   IF UPPER(ALLT(THIS.Nodes[i].Name))==UPPER(ALLT(pcNodeName))
		    nIndex=i
		    EXIT
		   ENDIF
		  ENDFOR
		  
		  RETURN nIndex
	ENDPROC


	*-- Determina si existe un subnodo en el nodo actual con el nombre indicado.
	PROCEDURE isnode
		LPARAMETERS pcPropName

		RETURN (THIS.FindNode(pcPropName)<>0)
	ENDPROC


	*-- Añade un nuevo subnodo al nodo actual
	PROCEDURE addnode
		LPARAMETERS poNode,pcData

		  DO CASE
		     CASE PCOUNT()=0
		          poNode=CREATE("XMLNodeClass")
		          
		     CASE VARTYPE(poNode)="C"
		          LOCAL cName,cNameSpace
		          cName=poNode
		          cNameSpace = ""
		          IF AT(":",cName)<>0
		           cNameSpace = LEFT(cName,AT(":",cName) - 1)
		           cName = SUBS(cName,AT(":",cNAme) + 1)
		          ENDIF
		          poNode=CREATE("XMLNodeClass")
		          poNode.Name = cName
		          poNode.NameSpace = cNameSpace
		  ENDCASE
		  poNode.createNodeLinks = THIS.createNodeLinks
		  poNode.indentString = THIS.indentString
		  
		  *-- Si el nodo no tiene namespace pero el padre si, se asume el 
		  *   namespace del padre (VES Nov 11, 2011)
		  IF EMPTY(poNode.nameSpace)
		   poNode.nameSpace = THIS.nameSpace
		  ENDIF
		  
		  THIS.nNodeCount=THIS.nNodeCount + 1
		  DIMENSION THIS.Nodes[THIS.nNodeCount]
		  THIS.Nodes[THIS.nNodeCount]=poNode
		  poNode.ParentNode=THIS
		  IF PCOUNT()=2
		   poNode.Data=pcData
		  ENDIF
		  
		  IF THIS.createNodeLinks  && Nov 11, 2011
 		   LOCAL cNodeLink
		   cNodeLink="_"+poNode.Name
		   IF TYPE("THIS."+cNodeLink)="U"
		    THIS.AddProperty(cNodeLink,poNode)
		   ELSE
		    STORE poNode TO ("THIS."+cNodeLink) 
		   ENDIF
		  ENDIF
		  
		  RETURN poNode
	ENDPROC


	*-- Elimina un subnodo del nodo actual
	PROCEDURE removenode
		LPARAMETERS puIndex

		  IF VARTYPE(puIndex)="C"
		   puIndex=THIS.FindNode(puIndex)
		  ENDIF
		  
		  IF BETWEEN(puIndex,1,THIS.nNodeCount)
		   *
		   LOCAL cNodeLink
		   cNodeLink="_"+THIS.Nodes[puIndex].Name
		   STORE NULL TO ("THIS."+cNodeLink)
		   
		   THIS.Nodes[puIndex]=NULL
		   ADEL(THIS.Nodes,puIndex)
		   THIS.nNodeCount=THIS.nNodeCount - 1
		   *
		  ENDIF
	ENDPROC


	HIDDEN PROCEDURE fullpath_access
		  LOCAL cPath,oNode
		  cPath=PROPER(THIS.Name)
		  oNode=THIS
		  DO WHILE (NOT ISNULL(oNode.ParentNode)) 
		   IF oNode.ParentNode.Name<>"ROOT"
		    cPath=PROPER(oNode.ParentNode.Name) + "\" + cPath
		   ENDIF 
		   oNode=oNode.ParentNode
		  ENDDO
		  
		  RETURN cPath
	ENDPROC


	HIDDEN PROCEDURE fullpath_assign
		LPARAMETERS vNewVal
	ENDPROC



    * ToString (VES Nov 12, 2011)
    * Devuelve una representacion en string del nodo y su contenido
    *  
    PROCEDURE ToString(pnMargin)
     *
		  LOCAL nDeep,cAlign,i,uValue,cResult
		  nDeep=OCCURS("\",THIS.FullPath) 
		  cCRLF = CHR(13) + CHR(10)
		  cAlign=REPL(THIS.IndentString,nDeep)
		  IF CFDEVL(pnMargin,0) > 0
		   cAlign = REPL(THIS.indentString,pnMargin) + cAlign
		  ENDIF
		  
		  cResult = cAlign + "<" + THIS.nodeName
		  
		  FOR i=1 TO THIS.PropCount
		   IF i=1
		    cResult = cResult + SPACE(1)
		   ENDIF
		   uValue=THIS.Props(i).Value
		   DO CASE
		      CASE VARTYPE(uValue)="C"
		           uValue=["]+uValue+["]
		      CASE VARTYPE(uValue)="D"
		           uValue=[{]+DTOC(uValue)+[}]
		      CASE VARTYPE(uValue)="T"
		           uValue=[{]+TTOC(uValue)+[}]
		      CASE VARTYPE(uValue)="N" AND INT(uValue)<>uValue
		           uValue=ALLT(STR(uValue,30,6))
		      CASE VARTYPE(uValue)="N" AND INT(uValue)=uValue
		           uValue=ALLT(STR(uValue,30))
		      CASE VARTYPE(uValue)="L"
		           uValue=IIF(uValue,".T.",".F.")
		      OTHERWISE
		            uValue=TRANS(uValue,"")
		   ENDCASE
		   cResult = cResult + THIS.Props[i].Id + "=" + uValue
		   IF i < THIS.PropCount
		    cResult = cResult + SPACE(1)
		   ENDIF
		  ENDFOR

		  IF THIS.PropCount=0 AND THIS.NodeCount=0
		   *
		   IF ISNULL(THIS.Data)
		    cResult = cResult + "/>"
		   ELSE
		    cResult = cResult + ">" + THIS.Data + "</" + THIS.nodeName + ">"
		   ENDIF
		   *
		  ELSE          
		   *
		   IF THIS.NodeCount=0
		    IF ISNULL(THIS.Data)
		     cResult = cResult + "/>"
		    ELSE
		     cResult = cResult + ">" + THIS.Data + "</" + THIS.nodeName + ">"
		    ENDIF    
		   ELSE
		    IF ISNULL(THIS.Data)
		     cResult = cResult + ">"
		    ELSE
		     cResult = cResult + ">" + THIS.Data
		    ENDIF    
		    LOCAL cChildren
		    FOR i=1 TO THIS.NodeCount
		      cChildren = THIS.Nodes[i].ToString(pnMargin)
		      cResult = cResult + CRLF + cChildren
		    ENDFOR 
		    cResult = cResult + cCRLF + cAlign + "</" + THIS.nodeName + ">"
		   ENDIF 
		   *
		  ENDIF         
     
          RETURN cResult
     *
    ENDPROC
ENDDEFINE


DEFINE CLASS XmlPropClass AS custom

	*-- Valor de la propiedad
	Value = "NULL"
	Id = "xmlpropclass"

ENDDEFINE




*-----------------------------------------------------------------------------
* HEXUTILS.PRG
* Funciones varias relacionadas con el sistema hexadecimal
*
* Autor: Victor Espina
* Fecha: 10-OCT-2002
*
* Contenido:
* Dec2Hex(pnDec)		Convierte un número decimal en hexadecimal
* Hex2Dec(pcHex)		Inverso de Dec2Hex
* Str2Hex(pcStr)		Convierte una cadena en su expresión hexadecimal
* Hex2Str(pcHexStr)		Inverso de Str2Hex
*
*-----------------------------------------------------------------------------


*-- DEC2HEX
*   Convierte un nro. decimal y hexagesimal
*
PROC Dec2Hex(nDec)
 *
 local nResto,cHex,nDig
 nResto=nDec
 cHex=""
 do while nResto > 15
  nDig=mod(nResto,16)
  if nDig < 10
   cHex=str(nDig,1) + cHex
  else
   cHex=chr(55+nDig) + cHex
  endif
  nResto=int(nResto / 16)
 enddo

 nDig=nResto 
 if nDig < 10
  cHex=str(nDig,1) + cHex
 else
  cHex=chr(55+nDig) + cHex
 endif
 
 
 return cHex
 *
ENDPROC


*-- HEX2DEC
*   Convierte un nro hexagesimal en decimal
*
PROC Hex2Dec(cHex)
 *
 local nDec,nDig,i,nExp
 nDec=0
 for i=1 to len(cHex)
  nExp=len(cHex)-i
  nDig=subs(cHex,i,1)
  if nDig $ "ABCDEF"
   nDig=asc(nDig) - 55
  else
   nDig=int(val(nDig))
  endif  
  nDec=nDec + ( nDig*(16^nExp) )
 endfor
 
 return nDec
 *
ENDPROC


*-- STR2HEX
*   Convierte una cadena en su expresión hexadecimal, llevando a Hexadecimal el valor
*   ASCII de cada uno de sus caracteres.
*
PROC Str2Hex(pcStr)
 *
 local cHex,nLen,i
 cHex=""
 nLen=len(pcStr)
 for i=1 to nLen
  cHex=cHex + padl( Dec2Hex( asc(subs(pcStr,i,1)) ) ,2,"0")
 endfor
 
 return cHex
 *
ENDPROC


*-- HEX2STR
*   Inverso de Str2Hex
*
PROC Hex2Str(pcHexStr)
 *
 local nLen,cDec,i
 nLen=len(pcHexStr)
 cDec=""
 for i=1 to nLen step 2
  cDec=cDec + chr( Hex2Dec( subs(pcHexStr,i,2) ) )
 endfor
 
 return cDec
 *
ENDPROC


*-- CFDAsc2UTF8
*   Toma una cadena en formato AscII / ANSI y devuelve
*   su equivalente en formato UTF-8
*
*   Autor: V. Espina
*   Fecha: Dic 2010
*   
*   Basado en un articulo de elem_125 en everything2.com:
*   http://everything2.com/title/Converting+ASCII+to+UTF-8
*
PROCEDURE CFDAsc2UTF8(pcString)
 *
 LOCAL cBuff, c, i, h, l 
 cBuff = ""
 
 FOR i = 1 TO LEN(pcString)
  c = ASC(SUBS(pcString,i,1))
  IF c < 128
   cBuff = cBuff + CHR(c)
  ELSE
   h = BITOR(BITRSHIFT(c,6),0xC0)
   l = BITOR(BITAND(c,0x3F),0x80)
   cBuff = cBuff + CHR(h) + CHR(l)
  ENDIF 
 ENDFOR

 RETURN cBuff
 *
ENDPROC



*-- CFDUTF82Asc
*   Toma una cadena en formato AscII / ANSI y devuelve
*   su equivalente en formato UTF-8
*
*   Autor: V. Espina
*   Fecha: Dic 2010
*   
*   Basado en informacion de wikipedia:
*   http://en.wikipedia.org/wiki/UTF-8
*
PROCEDURE CFDUTF82Asc(pcString)
 *
 LOCAL cBuff, i, nAsc, c
 nAsc = 0
 cBuff = ""
 FOR i = 1 TO LEN(pcString)
  *
  c = ASC(SUBS(pcString,i,1))
  IF c < 128
   IF nAsc > 0
    cBuff = cBuff + CHR(nAsc)
    nAsc = 0
   ENDIF 
   cBuff = cBuff + CHR(c)
  ELSE
   IF BITTEST(c,6) 
    nSize = BITRSHIFT(BITAND(c,0x60),5)
    nAsc = BITLSHIFT(BITCLEAR(BITCLEAR(c,7),6),6 * (nSize - 1))
   ELSE
    nAsc = BITOR(nAsc, BITCLEAR(BITCLEAR(c,7),6))
   ENDIF 
  ENDIF 
  *
 ENDFOR
 
 RETURN cBuff
 *
ENDPROC



* -----------------------------------------------------------------------------------
* IRCSA Software
* Arturo Ramos
* www.ircsasoftware.com.mx
*
* Programa para lee un CFD/CFDI y pasarlo a cursores .... v 1.0.0 - Noviembre 2010
* 
* Dic 23, 2010
* Cambios varios realizados por Victor Espina para adaptarlo al uso en VFP6 y permitir
* crear los cursores con un prefijo configurable.
*
* Dic 27, 2010
* Se incluyo un 3er parametro opcional llamado pcOpenSSL, el cual indica la ruta
* hacia el archivo OPENSSL.EXE, el cual es necesario para la funcion CFDExtraerCadenaOriginal.
*
* Si no se indica, se asume .\SSL
*
* Ago  7, 2010 - Arturo Ramos
* Se adapta para poder recibir un CFDI.
*
* Parametros de entrada
* ---------------------
* ArchivoXML				Archivo XML a cargar en cursores (si no se proporciona lo pide)
*
* Cursores de salida
* ------------------
* <prefijo>DG			Contiene el nodo Comprobante
* <prefijo>CO			Contiene los nodos Conceptos
* <prefijo>AD			Contiene los nodos informacionAduanera
* <prefijo>RE			Contiene los nodos Retenciones
* <prefijo>TR			Contiene los nodos Traslados
*
* -----------------------------------------------------------------------------------
PROCEDURE CFDToCursor
PARAMETERS pArchivoXML, pcCursorPreFix, pcOpenSSL

CFDConf.ultimoError = ""

IF PCOUNT() = 2
 pcOpenSSL = CFDConf.openSSL
ENDIF

LOCAL ArchivoXML

IF TYPE('pArchivoXML') != 'C' THEN 
	ArchivoXML = GETFILE("Comprobante digital(*.xml):XML", "Comprobante", "Abrir", 0, "Abrir archivo")
	IF EMPTY(ArchivoXML)
  	    CFDConf.ultimoError = "Debe indicar el comprobante digital a leer"
  	    RETURN .F.
	ENDIF 
ELSE 
	ArchivoXML = pArchivoXML
ENDIF 	


 *-- VES Dic 23, 2010
 *   Se define los nombres de los cursores
 *
 PRIVATE cGenerales, cConceptos, cAduanas, cRetenciones, cTraslados
 IF EMPTY(pcCursorPrefix)
  pcCursorPrefix="Q"
 ENDIF
 cGenerales = pcCursorPrefix + "DG" 
 cConceptos = pcCursorPrefix + "CO" 
 cAduanas = pcCursorPrefix + "AD"  
 cRetenciones = pcCursorPrefix + "RE" 
 cTraslados = pcCursorPrefix + "TR"    


LOCAL olNodes 

* Crea los cursores para contener los datos
DO CreaFactura 

* Datos Generales de la Factura 
SELECT (cGenerales)
INSERT INTO ;
	(cGenerales) (folio) ; && Se da de alta un registro en blanco 
	Value ("   ") 

* Se utiliza MSXML para cargar y leer el XML
* Web de MSXML DOM http://msdn.microsoft.com/en-us/library/ms760218%28v=VS.85%29.aspx
* Estandar XML w3  http://www.w3schools.com/xml/default.asp
* Manaul XML DOM   http://www.w3schools.com/dom/dom_intro.asp

xdoc=CREATEOBJECT('MSXML2.DOMdocument')

xdoc.LOAD(ArchivoXML)
If (xdoc.parseError.errorCode <> 0) Then
   myErr = xdoc.parseError
   CFDConf.ultimoError = myErr.reason
   RETURN .F.
ENDIF 

*-- Obtiene el nombre del nodo root, puede ser 'Comprobante' para CFD o 'cfdi:Comprobante' para CFDI
oRootNode = xdoc.documentElement
cRootTagName = oRootNode.tagName

IF cRootTagName = "cfdi:Comprobante"
 lcPrefijo = "cfdi:"
ELSE 
 lcPrefijo = ""
ENDIF


* ---------------------------------------------------------------------------
* <Comprobante>
* Estándar para la expresión de comprobantes fiscales digitales.
* ---------------------------------------------------------------------------
olNodes = xdoc.selectNodes("//"+lcPrefijo+"Comprobante")
IF olNodes.LENGTH <= 0 THEN 
    CFDConf.ultimoError = "Comprobante inválido. Nodo <"+lcPrefijo+"Comprobante> no presente."
	RETURN .F.
ENDIF 
FOR i = 0 TO olNodes.LENGTH - 1
	FOR j = 0 TO olNodes.ITEM(i).ATTRIBUTES.LENGTH - 1
		sAtributeName = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).nodeName
		sAtributeValues = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).TEXT
		*? i,j,sAtributeName + "=" + sAtributeValues	&& Quitar comentario para ver el valor regresado.
		
		DO CASE 
			CASE sAtributeName = "version"
				UPDATE (cGenerales) SET versions   = sAtributeValues		&& Atributo requerido con valor prefijado a 2.0 que indica la versión del estándar bajo el que se encuentra expresado el comprobante.
			CASE sAtributeName = "serie"
				UPDATE (cGenerales) SET serie      = sAtributeValues		&& Atributo opcional para precisar la serie a la que corresponde el comprobante. Este atributo acepta una cadena de caracteres alfabéticos de 1 a 10 caracteres sin incluir caracteres acentuados.
			CASE sAtributeName = "folio"
				UPDATE (cGenerales) SET folio      = sAtributeValues		&& Atributo requerido que acepta un valor numérico entero superior a 0 que expresa el folio del comprobante.
			CASE sAtributeName = "fecha"
				UPDATE (cGenerales) SET fecha      = sAtributeValues		&& Atributo requerido para la expresión de la fecha y hora de expedición del comprobante fiscal. Se expresa en la forma aaaa-mm-ddThh:mm:ss, de acuerdo con la especificación ISO 8601.
			CASE sAtributeName = "sello"
				UPDATE (cGenerales) SET sello      = sAtributeValues		&& Atributo requerido para contener el sello digital del comprobante fiscal, al que hacen referencia las reglas de resolución miscelánea aplicable. El sello deberá ser expresado cómo una cadena de texto en formato Base 64.
			CASE sAtributeName = "noAprobacion"
				UPDATE (cGenerales) SET noAprobaci = sAtributeValues		&& CFD: Atributo requerido para precisar el número de aprobación emitido por el SAT, para el rango de folios al que pertenece el folio particular que ampara el comprobante fiscal digital.
			CASE sAtributeName = "anoAprobacion"
				UPDATE (cGenerales) SET anoAprobac = sAtributeValues		&& CFD: Atributo requerido para precisar el año en que se solicito el folio que se están utilizando para emitir el comprobante fiscal digital.
			CASE sAtributeName = "formaDePago"
				UPDATE (cGenerales) SET formaDePag = sAtributeValues		&& Atributo requerido para precisar la forma de pago que aplica para este comprobante fiscal digital. Se utiliza para expresar Pago en una sola exhibición o número de parcialidad pagada contra el total de parcialidades, Parcialidad 1 de X.
			CASE sAtributeName = "noCertificado"
				UPDATE (cGenerales) SET noCertific = sAtributeValues		&& Atributo requerido para expresar el número de serie del certificado de sello digital que ampara al comprobante, de acuerdo al acuse correspondiente a 20 posiciones otorgado por el sistema del SAT.
			CASE sAtributeName = "certificado"
				UPDATE (cGenerales) SET certific   = sAtributeValues		&& Atributo opcional que sirve para expresar el certificado de sello digital que ampara al comprobante como texto, en formato base 64.
			CASE sAtributeName = "condicionesDePago"
				UPDATE (cGenerales) SET condicione = sAtributeValues		&& Atributo opcional para expresar las condiciones comerciales aplicables para el pago del comprobante fiscal digital.
			CASE sAtributeName = "subTotal"
				UPDATE (cGenerales) SET subTotal   = VAL(sAtributeValues)&& Atributo requerido para representar la suma de los importes antes de descuentos e impuestos.
			CASE sAtributeName = "descuento"
				UPDATE (cGenerales) SET descuento  = VAL(sAtributeValues)&& Atributo opcional para representar el importe total de los descuentos aplicables antes de impuestos.
			CASE sAtributeName = "motivoDescuento"
				UPDATE (cGenerales) SET motivoDesc = sAtributeValues		&& Atributo opcional para expresar el motivo del descuento aplicable.
			CASE sAtributeName = "total"
				UPDATE (cGenerales) SET total      = VAL(sAtributeValues)&& Atributo requerido para representar la suma del subtotal, menos los descuentos aplicables, más los impuestos trasladados, menos los impuestos retenidos.
			CASE sAtributeName = "metodoDePago"
				UPDATE (cGenerales) SET metodoDePa = sAtributeValues		&& Atributo opcional de texto libre para expresar el método de pago de los bienes o servicios amparados por el comprobante. Se entiende como método de pago leyendas tales como: cheque, tarjeta de crédito o debito, depósito en cuenta, etc.
			CASE sAtributeName = "tipoDeComprobante"
				UPDATE (cGenerales) SET tipoDeComp = sAtributeValues		&& Atributo requerido para expresar el efecto del comprobante fiscal para el contribuyente emisor.
			CASE sAtributeName = "TipoCambio"
				UPDATE (cGenerales) SET TipoCambio = sAtributeValues		&& CFDI: Atributo opcional para representar el tipo de cambio conforme a la moneda usada
			CASE sAtributeName = "Moneda"
				UPDATE (cGenerales) SET Moneda     = sAtributeValues		&& CFDI: Atributo opcional para expresar la moneda utilizada para expresar los montos
			
		ENDCASE 
	NEXT j
NEXT i

*-- Arturo Ramos
*   Si hay un monto de descuento pero no un motivo, se asigna un motivo generico
SELECT (cGenerales)
IF descuento > 0 AND EMPTY(motivoDesc)
 REPLACE motivoDesc WITH "Descuento"
ENDIF

* ---------------------------------------------------------------------------
* <Comprobante> -- <Emisor>
* Nodo requerido para expresar la información del contribuyente emisor del comprobante.
* ---------------------------------------------------------------------------
olNodes = xdoc.selectNodes("//"+lcPrefijo+"Comprobante/"+lcPrefijo+"Emisor")
IF olNodes.LENGTH <= 0 THEN 
    CFDConf.ultimoError = "Comprobante inválido. Nodo <"+lcPrefijo+"Emisor> no presente."
	RETURN .F.
ENDIF 
FOR i = 0 TO olNodes.LENGTH - 1
	FOR j = 0 TO olNodes.ITEM(i).ATTRIBUTES.LENGTH - 1
		sAtributeName = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).nodeName
		sAtributeValues = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).TEXT
		*? i,j,sAtributeName + "=" + sAtributeValues	&& Quitar comentario para ver el valor regresado.
		
		DO CASE 
			CASE sAtributeName = "rfc"
				UPDATE (cGenerales) SET Erfc       = sAtributeValues		&& Atributo requerido para la Clave del Registro Federal de Contribuyentes correspondiente al contribuyente emisor del comprobante sin guiones o espacios.
			CASE sAtributeName = "nombre"
				UPDATE (cGenerales) SET Enombre    = sAtributeValues		&& Atributo requerido para el nombre o razón social del contribuyente emisor del comprobante.
		ENDCASE 
	NEXT j
NEXT i

* ---------------------------------------------------------------------------
* <Comprobante> -- <Emisor> -- <DomicilioFiscal>
* Nodo requerido para precisar la información de ubicación del domicilio fiscal del contribuyente emisor.
* ---------------------------------------------------------------------------
olNodes = xdoc.selectNodes("//"+lcPrefijo+"Comprobante/"+lcPrefijo+"Emisor/"+lcPrefijo+"DomicilioFiscal")
IF olNodes.LENGTH <= 0 THEN 
    CFDConf.ultimoError = "Comprobante inválido. Nodo <"+lcPrefijo+"DomicilioFiscal> del Emisor no presente."
	RETURN .F.
ENDIF 
FOR i = 0 TO olNodes.LENGTH - 1
	FOR j = 0 TO olNodes.ITEM(i).ATTRIBUTES.LENGTH - 1
		sAtributeName = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).nodeName
		sAtributeValues = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).TEXT
		*? i,j,sAtributeName + "=" + sAtributeValues	&& Quitar comentario para ver el valor regresado.
		
		DO CASE 
			CASE sAtributeName = "calle"
				UPDATE (cGenerales) SET Ecalle     = sAtributeValues		&& Este atributo requerido sirve para precisar la avenida, calle, camino o carretera donde se da la ubicación.
			CASE sAtributeName = "noExterior"
				UPDATE (cGenerales) SET EnoExterio = sAtributeValues		&& Este atributo opcional sirve para expresar el número particular en donde se da la ubicación sobre una calle dada.
			CASE sAtributeName = "noInterior"
				UPDATE (cGenerales) SET EnoInterio = sAtributeValues		&& Este atributo opcional sirve para expresar información adicional para especificar la ubicación cuando calle y número exterior (noExterior) no resulten suficientes para determinar la ubicación de forma precisa.
			CASE sAtributeName = "colonia"
				UPDATE (cGenerales) SET Ecolonia   = sAtributeValues		&& Este atributo opcional sirve para precisar la colonia en donde se da la ubicación cuando se desea ser más específico en casos de ubicaciones urbanas.
			CASE sAtributeName = "localidad"
				UPDATE (cGenerales) SET Elocalidad = sAtributeValues		&& Atributo opcional que sirve para precisar la ciudad o población donde se da la ubicación.
			CASE sAtributeName = "referencia"
				UPDATE (cGenerales) SET Ereferen   = sAtributeValues		&& Atributo opcional para expresar una referencia de ubicación adicional.
			CASE sAtributeName = "municipio"
				UPDATE (cGenerales) SET Emunicipio = sAtributeValues		&& Atributo requerido que sirve para precisar el municipio o delegación (en el caso del Distrito Federal) en donde se da la ubicación.
			CASE sAtributeName = "estado"
				UPDATE (cGenerales) SET Eestado    = sAtributeValues		&& Atributo requerido que sirve para precisar el estado o entidad federativa donde se da la ubicación.
			CASE sAtributeName = "pais"
				UPDATE (cGenerales) SET Epais      = sAtributeValues		&& Atributo requerido que sirve para precisar el país donde se da la ubicación.
			CASE sAtributeName = "codigoPostal"
				UPDATE (cGenerales) SET EcodigoPos = sAtributeValues		&& Atributo requerido que sirve para asentar el código postal en donde se da la ubicación.
		ENDCASE 
	NEXT j
NEXT i

* ---------------------------------------------------------------------------
* <Comprobante> -- <Emisor> -- <ExpedidoEn>
* Nodo opcional para precisar la información de ubicación del domicilio en donde es emitido el comprobante fiscal en caso de que sea distinto del domicilio fiscal del contribuyente emisor.
* ---------------------------------------------------------------------------
olNodes = xdoc.selectNodes("//"+lcPrefijo+"Comprobante/"+lcPrefijo+"Emisor/"+lcPrefijo+"ExpedidoEn")
FOR i = 0 TO olNodes.LENGTH - 1
	FOR j = 0 TO olNodes.ITEM(i).ATTRIBUTES.LENGTH - 1
		sAtributeName = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).nodeName
		sAtributeValues = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).TEXT
		*? i,j,sAtributeName + "=" + sAtributeValues	&& Quitar comentario para ver el valor regresado.
		
		DO CASE
			CASE sAtributeName = "calle"
				UPDATE (cGenerales) SET Xcalle     = sAtributeValues		&& Este atributo requerido sirve para precisar la avenida, calle, camino o carretera donde se da la ubicación.
			CASE sAtributeName = "noExterior"
				UPDATE (cGenerales) SET XnoExterio = sAtributeValues		&& Este atributo opcional sirve para expresar el número particular en donde se da la ubicación sobre una calle dada.
			CASE sAtributeName = "noInterior"
				UPDATE (cGenerales) SET XnoInterio = sAtributeValues		&& Este atributo opcional sirve para expresar información adicional para especificar la ubicación cuando calle y número exterior (noExterior) no resulten suficientes para determinar la ubicación de forma precisa.
			CASE sAtributeName = "colonia"
				UPDATE (cGenerales) SET Xcolonia   = sAtributeValues		&& Este atributo opcional sirve para precisar la colonia en donde se da la ubicación cuando se desea ser más específico en casos de ubicaciones urbanas.
			CASE sAtributeName = "localidad"
				UPDATE (cGenerales) SET Xlocalidad = sAtributeValues		&& Atributo opcional que sirve para precisar la ciudad o población donde se da la ubicación.
			CASE sAtributeName = "referencia"
				UPDATE (cGenerales) SET Xreferen   = sAtributeValues		&& Atributo opcional para expresar una referencia de ubicación adicional.
			CASE sAtributeName = "municipio"
				UPDATE (cGenerales) SET Xmunicipio = sAtributeValues		&& Atributo requerido que sirve para precisar el municipio o delegación (en el caso del Distrito Federal) en donde se da la ubicación.
			CASE sAtributeName = "estado"
				UPDATE (cGenerales) SET Xestado    = sAtributeValues		&& Atributo requerido que sirve para precisar el estado o entidad federativa donde se da la ubicación.
			CASE sAtributeName = "pais"
				UPDATE (cGenerales) SET Xpais      = sAtributeValues		&& Atributo requerido que sirve para precisar el país donde se da la ubicación.
			CASE sAtributeName = "codigoPostal"
				UPDATE (cGenerales) SET XcodigoPos = sAtributeValues		&& Atributo requerido que sirve para asentar el código postal en donde se da la ubicación.
		ENDCASE 
	NEXT j
NEXT i


* ---------------------------------------------------------------------------
* <Comprobante> -- <Receptor>
* Nodo requerido para precisar la información del contribuyente receptor del comprobante.
* ---------------------------------------------------------------------------
olNodes = xdoc.selectNodes("//"+lcPrefijo+"Comprobante/"+lcPrefijo+"Receptor")
IF olNodes.LENGTH <= 0 THEN 
    CFDConf.ultimoError = "Comprobante inválido. Nodo <"+lcPrefijo+"Receptor> no presente."
	RETURN .F.
ENDIF 
FOR i = 0 TO olNodes.LENGTH - 1
	FOR j = 0 TO olNodes.ITEM(i).ATTRIBUTES.LENGTH - 1
		sAtributeName = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).nodeName
		sAtributeValues = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).TEXT
		*? i,j,sAtributeName + "=" + sAtributeValues	&& Quitar comentario para ver el valor regresado.
		
		DO CASE
			CASE sAtributeName = "rfc"
				UPDATE (cGenerales) SET Rrfc       = sAtributeValues		&& Atributo requerido para precisar la Clave del Registro Federal de Contribuyentes correspondiente al contribuyente receptor del comprobante.
			CASE sAtributeName = "nombre"
				UPDATE (cGenerales) SET Rnombre    = sAtributeValues		&& Atributo opcional para precisar el nombre o razón social del contribuyente receptor.
		ENDCASE 
	NEXT j
NEXT i


* ---------------------------------------------------------------------------
* <Comprobante> -- <Receptor> -- <Domicilio>
* Nodo opcional para la definición de la ubicación donde se da el domicilio del receptor del comprobante fiscal.
* ---------------------------------------------------------------------------
olNodes = xdoc.selectNodes("//"+lcPrefijo+"Comprobante/"+lcPrefijo+"Receptor/"+lcPrefijo+"Domicilio")
FOR i = 0 TO olNodes.LENGTH - 1
	FOR j = 0 TO olNodes.ITEM(i).ATTRIBUTES.LENGTH - 1
		sAtributeName = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).nodeName
		sAtributeValues = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).TEXT
		*? i,j,sAtributeName + "=" + sAtributeValues	&& Quitar comentario para ver el valor regresado.
		
		DO CASE
			CASE sAtributeName = "calle"
				UPDATE (cGenerales) SET Rcalle     = sAtributeValues		&& Este atributo opcional sirve para precisar la avenida, calle, camino o carretera donde se da la ubicación.
			CASE sAtributeName = "noExterior"
				UPDATE (cGenerales) SET RnoExterio = sAtributeValues		&& Este atributo opcional sirve para expresar el número particular en donde se da la ubicación sobre una calle dada.
			CASE sAtributeName = "noInterior"
				UPDATE (cGenerales) SET RnoInterio = sAtributeValues		&& Este atributo opcional sirve para expresar información adicional para especificar la ubicación cuando calle y número exterior (noExterior) no resulten suficientes para determinar la ubicación de forma precisa.
			CASE sAtributeName = "colonia"
				UPDATE (cGenerales) SET Rcolonia   = sAtributeValues		&& Este atributo opcional sirve para precisar la colonia en donde se da la ubicación cuando se desea ser más específico en casos de ubicaciones urbanas.
			CASE sAtributeName = "localidad"
				UPDATE (cGenerales) SET Rlocalidad = sAtributeValues		&& Atributo opcional que sirve para precisar la ciudad o población donde se da la ubicación.
			CASE sAtributeName = "referencia"
				UPDATE (cGenerales) SET Rreferen   = sAtributeValues		&& Atributo opcional para expresar una referencia de ubicación adicional.
			CASE sAtributeName = "municipio"
				UPDATE (cGenerales) SET Rmunicipio = sAtributeValues		&& Atributo opcional que sirve para precisar el municipio o delegación (en el caso del Distrito Federal) en donde se da la ubicación.
			CASE sAtributeName = "estado"
				UPDATE (cGenerales) SET Restado    = sAtributeValues		&& Atributo opcional que sirve para precisar el estado o entidad federativa donde se da la ubicación.
			CASE sAtributeName = "pais"
				UPDATE (cGenerales) SET Rpais      = sAtributeValues		&& Atributo requerido que sirve para precisar el país donde se da la ubicación.
			CASE sAtributeName = "codigoPostal"
				UPDATE (cGenerales) SET RcodigoPos = sAtributeValues		&& Atributo opcional que sirve para asentar el código postal en donde se da la ubicación.
		ENDCASE 
	NEXT j
NEXT i

* ---------------------------------------------------------------------------
* <Comprobante> -- <Conceptos>
* Nodo requerido para enlistar los conceptos cubiertos por el comprobante.
* ---------------------------------------------------------------------------
SELECT (cConceptos)
olNodes = xdoc.selectNodes("//"+lcPrefijo+"Comprobante/"+lcPrefijo+"Conceptos")
IF olNodes.LENGTH <= 0 THEN 
    CFDConf.ultimoError = "Comprobante inválido. Nodo <"+lcPrefijo+"Conceptos> no presente."
	RETURN .F.
ENDIF 
LeerDatos(xdoc.selectNodes("//"+lcPrefijo+"Comprobante/"+lcPrefijo+"Conceptos"))	&& Función que recorre cada nodo hijo de un nodo padre dado.
SELECT (cGenerales)

* ---------------------------------------------------------------------------
* <Comprobante> -- <Impuestos>
* Nodo requerido para capturar los impuestos aplicables.
* ---------------------------------------------------------------------------
olNodes = xdoc.selectNodes("//"+lcPrefijo+"Comprobante/"+lcPrefijo+"Impuestos/")
IF olNodes.LENGTH <= 0 THEN 
	  CFDConf.ultimoError = "Comprobante inválido. Nodo <"+lcPrefijo+"Impuestos> no presente."
	RETURN .F.
ENDIF 
FOR i = 0 TO olNodes.LENGTH - 1
	FOR j = 0 TO olNodes.ITEM(i).ATTRIBUTES.LENGTH - 1
		sAtributeName = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).nodeName
		sAtributeValues = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).TEXT
		*? i,j,sAtributeName + "=" + sAtributeValues	&& Quitar comentario para ver el valor regresado.
		
		DO CASE
			CASE sAtributeName = "totalImpuestosTrasladados"
				UPDATE (cGenerales) SET TotImpTras = VAL(sAtributeValues) && Atributo opcional para expresar el total de los impuestos trasladados que se desprenden de los conceptos expresados en el comprobante fiscal digital.
			CASE sAtributeName = "totalImpuestosRetenidos"
				UPDATE (cGenerales) SET TotImpRet  = VAL(sAtributeValues) && Atributo opcional para expresar el total de los impuestos retenidos que se desprenden de los conceptos expresados en el comprobante fiscal digital.
		ENDCASE 
	NEXT j
NEXT i


* ---------------------------------------------------------------------------
* <Comprobante> -- <Impuestos> -- <Retenciones> -- <Retencion>  <<-- Uno para ISR y otro para IVA
* Nodo opcional para asentar o referir los impuestos trasladados aplicables.
* ---------------------------------------------------------------------------
SELECT (cRetenciones)
LeerDatos(xdoc.selectNodes("//"+lcPrefijo+"Comprobante/"+lcPrefijo+"Impuestos/"+lcPrefijo+"Retenciones"))	&& Función que recorre cada nodo hijo de un nodo padre dado.
GO TOP 
SCAN 
	DO CASE 
		CASE ALLTRIM(EVAL(cRetenciones+".impuesto")) = "ISR"
			UPDATE (cGenerales) SET ;
				RetISR = "ISR", ;
				TotRetISR = EVAL(cRetenciones+".importe")
		CASE ALLTRIM(EVAL(cRetenciones+".impuesto")) = "IVA"
			UPDATE (cGenerales) SET ;
				RetIVA = "IVA", ;
				TotRetIVA = EVAL(cRetenciones+".importe")
	ENDCASE 			
ENDSCAN 
SELECT (cGenerales)


* ---------------------------------------------------------------------------
* <Comprobante> -- <Impuestos> -- <Traslados> -- <Traslado>  <<-- Puede ser IVA (0%, 11% o 16%) o IEPS
* Nodo opcional para asentar o referir los impuestos trasladados aplicables.
* ---------------------------------------------------------------------------
SELECT (cTraslados)
LeerDatos(xdoc.selectNodes("//"+lcPrefijo+"Comprobante/"+lcPrefijo+"Impuestos/"+lcPrefijo+"Traslados"))	&& Función que recorre cada nodo hijo de un nodo padre dado.
GO TOP 
SCAN 
	DO CASE 
		CASE ALLTRIM(EVAL(cTraslados+".impuesto")) = "IVA"
			UPDATE (cGenerales) SET ;
				impuesto = "IVA", ;
				tasa = EVAL(cTraslados+".tasa"), ;
				importe = EVAL(cTraslados+".importe")
		CASE ALLTRIM(EVAL(cTraslados+".impuesto")) = "IEPS"
			UPDATE (cGenerales) SET ;
				TraIEPS = "IEPS", ;
				TraTasIEPS = EVAL(cTraslados+".tasa"), ;
				TotTraIEPS = EVAL(cTraslados+".importe")
	ENDCASE 			
ENDSCAN 
SELECT (cGenerales)


* ---------------------------------------------------------------------------
* <Comprobante> -- <Complemento> -- <TimbreFiscalDigital>
* Nodo opcional donde se incluirá el complemento Timbre Fiscal Digital de manera
* obligatoria y los nodos complementarios determinados por el SAT, de acuerdo a las
* disposiciones particulares a un sector o actividad especifica.
* ---------------------------------------------------------------------------
olNodes = xdoc.selectNodes("//"+lcPrefijo+"Comprobante/"+lcPrefijo+"Complemento/"+lcPrefijo+"TimbreFiscalDigital/")
FOR i = 0 TO olNodes.LENGTH - 1
	FOR j = 0 TO olNodes.ITEM(i).ATTRIBUTES.LENGTH - 1
		sAtributeName = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).nodeName
		sAtributeValues = olNodes.ITEM(i).ATTRIBUTES.ITEM(j).TEXT
		*? i,j,sAtributeName + "=" + sAtributeValues	&& Quitar comentario para ver el valor regresado.
		
		DO CASE
			CASE sAtributeName = "version"
				UPDATE (cGenerales) SET versionTFD = sAtributeValues
			CASE sAtributeName = "FechaTimbrado"
				UPDATE (cGenerales) SET fechaTFD  = sAtributeValues
			CASE sAtributeName = "selloCFD"
				UPDATE (cGenerales) SET selloCFD  = sAtributeValues
			CASE sAtributeName = "noCertificadoSAT"
				UPDATE (cGenerales) SET certSAT  = sAtributeValues
			CASE sAtributeName = "selloSAT"
				UPDATE (cGenerales) SET selloSAT  = sAtributeValues
			CASE sAtributeName = "UUID"
				UPDATE (cGenerales) SET UUID  = sAtributeValues
		ENDCASE 
	NEXT j
NEXT i
SELECT (cGenerales)

* --------------------------------------------------------------------------------
* Genera la cadena original
* --------------------------------------------------------------------------------
LOCAL strOriginal
strOriginal = CFDExtraerCadenaOriginal(ArchivoXML,pcOpenSSL)
UPDATE (cGenerales) SET cadenaOrig = strOriginal

* Muestra los datos
* Quitar comentarios para ver cursores creados
*!*	SELECT (cRetenciones)
*!*	BROWSE 
*!*	SELECT (cTraslados)
*!*	BROWSE
*!*	SELECT (cConceptos)
*!*	BROWSE
*!*	SELECT (cGenerales)
*!*	BROWSE 


RETURN 




* --------------------------------------------------------------------------------
* Función para obtener cada atributo de cada nodo hijo dado un nodo padre
* --------------------------------------------------------------------------------
FUNCTION LeerDatos
	LPARAMETERS root

	LOCAL CHILD 

	*!* Aqui se procesan los nodos
	FOR EACH CHILD IN root
		*? CHILD.nodeName
		
		DO CASE 
			CASE CHILD.nodeName == lcPrefijo+"Concepto"
				INSERT INTO (cConceptos) (cantidad) VALUES (0)
				FOR j = 0 TO CHILD.ATTRIBUTES.LENGTH - 1
					sAtributeName = CHILD.ATTRIBUTES.ITEM(j).nodeName
					sAtributeValues = CHILD.ATTRIBUTES.ITEM(j).TEXT
					*? j,sAtributeName + "=" + sAtributeValues
					DO CASE 
						CASE sAtributeName = "cantidad"
							REPLACE cantidad WITH VAL(sAtributeValues) IN (cConceptos)
						CASE sAtributeName = "unidad"
							REPLACE unidad WITH sAtributeValues IN (cConceptos)
						CASE sAtributeName = "noIdentificacion"
							REPLACE noID WITH sAtributeValues IN (cConceptos)
						CASE sAtributeName = "descripcion"
							REPLACE descripcio WITH sAtributeValues IN (cConceptos)
						CASE sAtributeName = "valorUnitario"
							REPLACE valorUnita WITH VAL(sAtributeValues) IN (cConceptos)
						CASE sAtributeName = "importe"
							REPLACE importe WITH VAL(sAtributeValues) IN (cConceptos)
					ENDCASE 
				ENDFOR
			
			CASE CHILD.nodeName == lcPrefijo+"Retencion"
				INSERT INTO (cRetenciones) (impuesto) VALUES (" ")
				FOR j = 0 TO CHILD.ATTRIBUTES.LENGTH - 1
					sAtributeName = CHILD.ATTRIBUTES.ITEM(j).nodeName
					sAtributeValues = CHILD.ATTRIBUTES.ITEM(j).TEXT
					*? j,sAtributeName + "=" + sAtributeValues
					DO CASE 
						CASE sAtributeName = "impuesto"
							REPLACE impuesto WITH sAtributeValues IN (cRetenciones)		&& Atributo requerido para señalar el tipo de impuesto retenido. ISR o IVA.
						CASE sAtributeName = "importe"
							REPLACE importe WITH VAL(sAtributeValues) IN (cRetenciones)	&& Atributo requerido para señalar el importe o monto del impuesto retenido.						
					ENDCASE 
				ENDFOR 
				
			CASE CHILD.nodeName == lcPrefijo+"Traslado"
				INSERT INTO (cTraslados) (impuesto) VALUES (" ")
				FOR j = 0 TO CHILD.ATTRIBUTES.LENGTH - 1
					sAtributeName = CHILD.ATTRIBUTES.ITEM(j).nodeName
					sAtributeValues = CHILD.ATTRIBUTES.ITEM(j).TEXT
					*? j,sAtributeName + "=" + sAtributeValues
					DO CASE 
						CASE sAtributeName = "impuesto"
							REPLACE impuesto WITH sAtributeValues IN (cTraslados)		&& Atributo requerido para señalar el tipo de impuesto retenido. ISR o IVA.
						CASE sAtributeName = "importe"
							REPLACE importe WITH VAL(sAtributeValues) IN (cTraslados)	&& Atributo requerido para señalar el importe o monto del impuesto retenido.
						CASE sAtributeName = "tasa"
							REPLACE tasa WITH VAL(sAtributeValues) IN (cTraslados)	&& Atributo requerido para señalar el importe o monto del impuesto retenido.
					ENDCASE 
				ENDFOR
		ENDCASE  
		*** Si el nodo que estamos procesando tiene descendencia volvemos a llamar a la función LeerDatos pasandole el nodo actual
		IF CHILD.hasChildNodes
			LeerDatos(CHILD.childNodes)
		ENDIF
	ENDFOR
ENDFUNC


* --------------------------------------------------------------------------------
* Procedimiento que crea el entorno de datos para contener la información del comprobante
* --------------------------------------------------------------------------------
PROCEDURE CreaFactura

	swError = .T.

	* Datos Generales de la Factura 
	CREATE CURSOR (cGenerales)    ;
	   (                    ;
	    versions   C(005)  ,; 
	    serie      C(020)  ,; 	&& De 1 a 10 Caracteres para CFD / hasta 20 para CFDI
	    folio      C(010)  ,; 	&& 10 Caracteres de 1 al 2147483647
	    fecha      C(020)  ,; 
	    noAprobaci C(014)  ,; 	&& 14 Máximo para CFDs
	    anoAprobac C(004)  ,; 	&& 4 Dígitos
	    formaDePag C(080)  ,; 
	    condicione C(250)  ,; 
	    metodoDePa C(250)  ,; 
	    motivoDesc C(250)  ,; 
	    subTotal   N(10,6) ,; 	&& Tipo especial: t_importe de 2 a 6 decimales
	    descuento  N(10,6) ,; 	&& Tipo especial: t_importe de 2 a 6 decimales
	    total      N(10,6) ,; 	&& Tipo especial: t_importe de 2 a 6 decimales
	    tipoDeComp C(010)  ,; 
	    noCertific C(030)  ,; 	&& Hasta 20 segun Anexo 20
	    sello      M       ,; 
	    certific   M       ,; 
	    cadenaorig M       ,; 
	    Enombre    C(150)  ,; 	&& 
	    Erfc       C(013)  ,;   && Tipo especial: t_RFC de 12-13 Caracteres
	    Ecalle     C(100)  ,; 
	    EcodigoPos C(010)  ,; 
	    Ecolonia   C(100)  ,; 	&& 
	    Ereferen   C(250)  ,; 
	    Eestado    C(050)  ,; 	&& 
	    Elocalidad C(050)  ,; 
	    Emunicipio C(050)  ,; 
	    EnoExterio C(050)  ,; 	&&
	    EnoInterio C(050)  ,; 	&&
	    Epais      C(010)  ,; 
	    Xcalle     C(100)  ,; 
	    XcodigoPos C(010)  ,; 
	    Xcolonia   C(100)  ,; 	&&
	    Xestado    C(050)  ,; 	&&
	    Xlocalidad C(050)  ,; 
	    Xreferen   C(250)  ,; 
	    Xmunicipio C(050)  ,; 
	    XnoExterio C(050)  ,; 	&&
	    XnoInterio C(050)  ,; 	&&
	    Xpais      C(010)  ,; 
	    Rnombre    C(150)  ,; 	&&
	    Rrfc       C(013)  ,; 	&& Tipo especial: t_RFC de 12-13 Caracteres
	    Rcalle     C(100)  ,; 
	    RcodigoPos C(010)  ,; 
	    Rcolonia   C(100)  ,; 	&& 
	    Rreferen   C(250)  ,; 	&& 
	    Restado    C(050)  ,; 	&& 
	    Rlocalidad C(050)  ,; 
	    Rmunicipio C(050)  ,;  
	    RnoExterio C(050)  ,; 	&& 
	    RnoInterio C(050)  ,; 	&& 
	    Rpais      C(010)  ,; 
	    TotImpTras N(10,6) ,; 	&& Tipo especial: t_importe de 2 a 6 decimales
	    RetISR     C(010)  ,; 
	    TotRetISR  N(10,6) ,; 	&& Tipo especial: t_importe de 2 a 6 decimales
	    RetIVA     C(010)  ,; 
	    TotRetIVA  N(10,6) ,; 	&& Tipo especial: t_importe de 2 a 6 decimales
	    TotImpRet  N(10,6) ,; 	&& Tipo especial: t_importe de 2 a 6 decimales
	    impuesto   C(010)  ,; 
	    tasa       N(10,6) ,; 	&& Tipo especial: t_importe de 2 a 6 decimales
	    importe    N(10,6) ,; 	&& Tipo especial: t_importe de 2 a 6 decimales
	    TraIEPS    C(004)  ,; 
		TraTasIEPS N(10,6) ,; 	&& Tipo especial: t_importe de 2 a 6 decimales
		TotTraIEPS N(10,6) ,; 	&& Tipo especial: t_importe de 2 a 6 decimales
	    referencia C(010)  ,; 
	    TipoCambio C(013)  ,;
	    Moneda     C(020)  ,; 
	    cliente    C(010)  ,; 
	    pedido     C(010)  ,; 
	    agente     C(010)  ,; 
	    embarque   C(020)  ,; 
	    proveedor  C(010)  ,; 
	    ordencompr C(010)  ,; 
	    rTelefono  C(030)  ,; 
	    eTelefono  C(030)  ,; 
	    eWeb       C(050)  ,; 
	    eMail      C(050)  ,; 
	    totalletra C(250)  ,; 
	    Notas      C(250)  ,; 
	    fechaCFD   C(050)  ,; 
	    fechaVence C(050)  ,; 
	    versionTFD c(010)  ,;
	    fechaTFD   c(020)  ,;
	    selloCFD   M       ,;
	    selloSAT   M       ,;
	    certSAT    c(030)  ,;
	    UUID       C(036)   ;
	   )

	* Datos de las partidas o conceptos que forman la factura
	CREATE CURSOR (cConceptos) ;
	   (                      ;
	    cantidad    N(10,3) ,; 
	    noID        C(020)  ,; 
	    descripcio  M		,;
	    InfoAduana  C(250)  ,; 
	    importe     N(10,6) ,; 	&& Tipo especial: t_importe de 2 a 6 decimales
	    unidad      C(010)  ,; 
	    valorUnita  N(10,6) ,; 	&& Tipo especial: t_importe de 2 a 6 decimales
	    nopredio    C(050)   ; 
	   )
	
	* Datos de retenciones
	CREATE CURSOR (cRetenciones) ;
		(                   ;
		 impuesto   C(004) ,; 	&& Puede ser ISR o IVA
		 importe    N(10,6) ; 	&& && Tipo especial: t_importe de 2 a 6 decimales
		)
		
	* Datos de traslados
	CREATE CURSOR (cTraslados) ;
		(                   ;
		 impuesto   C(004) ,; 	&& Puede ser IVA o IEPS
		 tasa       N(10,6),; 	&& Tipo especial: t_importe de 2 a 6 decimales
		 importe    N(10,6) ; 	&& Tipo especial: t_importe de 2 a 6 decimales
		)
		
	* Datos de información aduanera 
	CREATE CURSOR (cAduanas) ;
	   (                      ;
	    noID        C(020) ,; 
	    numero      C(020) ,; 
	    fecha       C(010) ,; 
	    aduana      C(020)  ;
	   )

	swError = .F.
	
RETURN 




*-- CFDDomicilio
*   Toma los distintos valores de un domicilio fiscal y los junta
*   en una sola cadena
*
PROCEDURE CFDDomicilio(pcCalle, pcNoExterior, pcNoInterior, pcReferencia, pcColonia, ;
                       pcLocalidad, pcMunicipio, pcEstado, pcCodPostal, pcPais)
 *
 LOCAL cDireccion
 cDireccion = ALLT(pcCalle) + " " + ALLT(pcNoExterior) + " " + ALLT(pcNoInterior) + "," + ;
              ALLT(pcReferencia) + "," + IIF(EMPTY(pcColonia),"","Col. "+ALLT(pcColonia)) + "," + ;
              IIF(EMPTY(pcCodPostal),"","CP "+ALLT(pcCodPostal)) + "," + ALLT(pcLocalidad) + "," + ;
              ALLT(pcMunicipio) + "," + ALLT(pcEstado) + "," + ALLT(pcPais)
              
 cDireccion = ALLT(cDireccion)
 DO WHILE AT(SPACE(2),cDireccion) > 0
  cDireccion = STRT(cDireccion,SPACE(2),SPACE(1))
 ENDDO
 DO WHILE AT(" ,",cDireccion) > 0
  cDireccion = STRT(cDireccion," ,",",")
 ENDDO
 DO WHILE AT(",,",cDireccion) > 0
  cDireccion = STRT(cDireccion,",,",",")
 ENDDO
 IF LEFT(cDireccion,1) = ","
  SUBS(cDireccion,2)
 ENDIF
 cDireccion = STRT(cDireccion,",",", ")
 
 RETURN cDireccion
 *
ENDPROC




*-- CFDPrint
*   Genera una representacion impresa de un CFD dado
*
*   Autor: V. Espina
*   Fecha: Dic 2010
*
PROCEDURE CFDPrint(pcXML, plPreview, plPDFMode, pcPDFTarget, plReplaceCO)
 *
  *-- Se lee el XML y se cargan los datos en cursores
  *
  IF NOT CFDToCursor(pcXML) 
   RETURN .F.
  ENDIF
  
  *-- Se reemplazan los conceptos por los que estan en el entorno (curConceptos)
  *
  *   VES Oct 10, 2011: Se elimino la clausula READWRITE para usar una tecnica 
  *   compatible con versiones de VFP anteriores a la 9
  *
  IF plReplaceCO
    SELECT cantidad, codigo as noId, descripcion as descripcio, "" as infoaduana, ;
  		   importe, unidad, precio_unit as valorunita, cuentapredial as nopredio ;
      FROM curConceptos ;
      INTO CURSOR QCOTEMP
    SELECT 0
    USE (DBF("QCOTEMP")) ALIAS QCO AGAIN
    USE IN QCOTEMP
  ENDIF 

  *-- Se anade una columna BANDA al cursor de conceptos
  *
  ALTER TABLE QCO ADD banda N (1)
  UPDATE QCO SET banda = 1


  *-- Se genera la banda de subtotal y descuento
  *
  INSERT INTO QCO (banda, descripcio, valorunita, importe) ;
           VALUES (2, "Sub / Total", 0.00, QDG.subtotal)

  IF QDG.descuento > 0
   INSERT INTO QCO (banda, descripcio, valorunita, importe) ;
            VALUES (2, QDG.motivoDesc, 0.00, -QDG.descuento)
  ENDIF



  *-- Se pasa la informacion de iva trasladado a la tabla de conceptos como banda-3
  *
  LOCAL cImpuesto,nTasa,nImporte
  SELECT QTR
  GO TOP
  SCAN
   *
   cImpuesto=impuesto
   nTasa=tasa
   nImporte=importe

   INSERT INTO QCO (banda, descripcio, valorunita, importe) ;
            VALUES (3, cImpuesto, nTasa, nImporte)
   *
   SELECT QTR
  ENDSCAN


  *-- Se pasa la informacion de retenciones a la tabla de conceptos como banda-4
  *
  LOCAL cImpuesto,nTasa,nImporte
  SELECT QRE
  GO TOP
  SCAN
   *
   cImpuesto=impuesto
   nImporte=importe

   INSERT INTO QCO (banda, descripcio, importe) ;
            VALUES (4, cImpuesto, nImporte)
   *
   SELECT QTR
  ENDSCAN


  *-- Se genera la banda de total
  *
  INSERT INTO QCO (banda, descripcio, valorunita, importe) ;
           VALUES (5, "Total", 0.00, QDG.total)



  *-- Se prepara el cursor principal
  *
  SELECT QCO
  GO TOP


  *-- Se emite el reporte
  *
  LOCAL cFormat
  cFormat = ALLT(CFDConf.formatoImpresion)
  
  DO CASE
     CASE plPreview
          REPORT FORM (cFormat) NOCONSOLE PREVIEW
          
     CASE plPDFMode   && Se utiliza PDFCreator
          pcPDFTarget = FULLPATH(pcPDFTarget)  && VES Ene 5, 2011
          LOCAL oPDF
          oPDF=CREATEOBJECT("PDFCreator.clsPDFCreator")
          oPDF.cStart()
          oPDF.cVisible=True
          oPDF.cClearCache()
          oPDF.cPrinterStop=False
          oPDF.cOption("AutosaveDirectory")=JUSTPATH(pcPDFTarget)
          oPDF.cOption("AutosaveFileName")=JUSTFNAME(pcPDFTarget)
          oPDF.cOption("UseAUtosave")=1
          oPDF.cOption("UseAutosaveDirectory")=1
          oPDF.cOption("AutosaveFormat")=0
          oPDF.cSaveOptions()

          SET PRINTER TO NAME PDFCreator
          REPORT FORM (cFormat) NOCONSOLE TO PRINT
          SET PRINTER TO
          
          SLEEP(3000)
          oPDF.cOption("UseAUtosave") = 0
          oPDF.cSaveOptions()
        
        
    
     
     OTHERWISE
          REPORT FORM (cFormat) NOCONSOLE PREVIEW IN SCREEN TO PRINT PROMPT
  ENDCASE
  
  
  *-- Se cierrn los cursores
  *
  USE IN QDG
  USE IN QCO
  USE IN QRE
  USE IN QTR
  USE IN QAD
 *
ENDPROC



*-- CFDNTOCESP
*   Convierte una cifra en letras en español, adaptado al uso especifico
*   en Mexico
*
*   Autor: V. Espina
*
PROC CFDNTOCESP(pnNumero)
 *
 *-- Se definen algunos datos necesarios
 *
 dimen aFactores[4],aCentenas[10],aDecenas[10],aUnidades[10],aEspeciales[5]
 aFactores[1]=""
 aFactores[2]="MIL"
 aFactores[3]="MILLON"
 aFactores[4]="MIL MILLONES"
 aCentenas[1]=""
 aCentenas[2]="CIENTO"
 aCentenas[3]="DOSCIENTOS"
 aCentenas[4]="TRESCIENTOS"
 aCentenas[5]="CUATROCIENTOS"
 aCentenas[6]="QUINIENTOS"
 aCentenas[7]="SEISCIENTOS"
 aCentenas[8]="SETECIENTOS"
 aCentenas[9]="OCHOCIENTOS"
 aCentenas[10]="NOVECIENTOS"
 aDecenas[1]=""
 aDecenas[2]="DIEZ"
 aDecenas[3]="VEINTE"
 aDecenas[4]="TREINTA"
 aDecenas[5]="CUARENTA"
 aDecenas[6]="CINCUENTA"
 aDecenas[7]="SESENTA"
 aDecenas[8]="SETENTA"
 aDecenas[9]="OCHENTA"
 aDecenas[10]="NOVENTA"
 aUnidades[1]=""
 aUnidades[2]="UNO"
 aUnidades[3]="DOS"
 aUnidades[4]="TRES"
 aUnidades[5]="CUATRO"
 aUnidades[6]="CINCO"
 aUnidades[7]="SEIS"
 aUnidades[8]="SIETE"
 aUnidades[9]="OCHO"
 aUnidades[10]="NUEVE"
 aEspeciales[1]="ONCE"
 aEspeciales[2]="DOCE"
 aEspeciales[3]="TRECE"
 aEspeciales[4]="CATORCE"
 aEspeciales[5]="QUINCE"
   
   
   
 *-- Se construye la parte entera de la cifra
 *
 local cCifra1,cLetras,nFact,nTercio,nCount,nFactor,nCentana,nDecena,nUnidad
 cCifra1=","+ltrim(trans(int(pnNumero),"999,999,999,999,999,999"))
 nCount=occurs(",",cCifra1)
 cLetras=""
   
 for nTercio=1 to nCount
  cTercio=subs(cCifra1,rat(",",cCifra1)+1,3)
  cCifra1=subs(cCifra1,1,rat(",",cCifra1)-1)
  nBase=int(val(cTercio))
   
  nCentena=int(nBase / 100)
  nBase=nBase - (int(nBase / 100) * 100)
  nDecena=int(nBase / 10)
  nUnidad=nBase - (int(nBase / 10) * 10)
  cFactor=aFactores[nTercio]
  if nTercio=3 and (nBase > 1 OR nDecena > 0 OR nCentena > 0)
   cFactor="MILLONES"
  endif
   
  cCentena=aCentenas[nCentena + 1]
  if nDecena > 1 or nUnidad=0
   cDecena=aDecenas[nDecena + 1]
   cUnidad=aUnidades[nUnidad + 1]
  else
   if nDecena=1 and between(nUnidad,1,5)
    cDecena=aEspeciales[nUnidad]
    cUnidad=""
   else
    cDecena=iif(nDecena=1,"DIEZ","")
    cUnidad=aUnidades[nUnidad + 1]
   endif
  endif
   
  do case
     case nCentena > 0 and nDecena=0 and nUnidad=0
          if nCentena = 1
           cTercio="CIEN "
          else
           cTercio=cCentena + " "
          endif
   
     case nCentena=0 and nDecena=0
          if nUnidad = 1
           if not empty(cFactor)
            cTercio="UN "
           else
            cTercio="UNO "
           endif
          else
           cTercio=cUnidad + " "
          endif
   
     otherwise
 		 cTercio=iif(not empty(cCentena),cCentena + " ","") + ;
 		         iif(not empty(cDecena),cDecena + " ","") + ;
 		         iif(not empty(cUnidad),iif(empty(cDecena),cUnidad,"Y "+cUnidad)+" ","")
  endcase
   
  if not empty(cTercio) 
   cLetras=cTercio + cFactor + " " + cLetras
  endif
   
 endfor
   
   
 *-- Se añaden los decimales
 *
 local nDec
 nDec=(pnNumero - int(pnNumero)) * 100
   
 cLetras=PROPER(RTRIM(cLetras)) + " Pesos con "+PADL(INT(nDec),2,"0") + "/100 M.N."
 
 cLetras=strt(cLetras,"  "," ")
   
 return cLetras
 *
ENDPROC




*-- CFDExtraerCadenaOriginal (Funcion)
*   Permite extraer la cadena original de un comprobante en formato XML
*
*   Basado en el codigo original de Arturo Ramos
*
FUNCTION CFDExtraerCadenaOriginal(pcXML, pcOpenSSL)
 *
 CFDConf.ultimoError = ""  
 
 *-- Se verifica que el archivo exista
 IF EMPTY(pcXML) OR NOT FILE(pcXML) 
  CFDConf.ultimoError = "El archivo indicado no existe"
  RETURN ""
 ENDIF
 
 *-- Se verifica que la carpeta indicada contenga el archivo OPENSSL.EXE
 IF EMPTY(pcOpenSSL)
  pcOpenSSL = CFDConf.openSSL
 ENDIF
 IF EMPTY(pcOpenSSL) OR NOT FILE(ADDBS(pcOpenSSL) + "OPENSSL.EXE")
  CFDConf.ultimoError = "No se encontro el archivo OPENSSL.EXE en la ruta indicada"
  RETURN ""
 ENDIF
 pcOpenSSL = ADDBS(FULLPATH(pcOpenSSL))
 
 
 
 *-- Se prepara un archivo BAT con los comandos a ejecutar
 LOCAL cBATFile,cCADFile,cXSLFile,cXSLTProc,cBuff
 cBATFile = GetTempfile("BAT") 
 cCADFile = FORCEEXT(cBATFile,"CAD")
 cXSLFile = FORCEEXT(cBATFile,"XSLT")
 cXSLTProc = GetShortName(pcOpenSSL + "XSLTPROC.EXE")
  
 cBuff = FILETOSTR(pcOpenSSL + IIF(CFDConf.XMLversion=3, "cadenaoriginal_3_0_local.xslt", "cadenaoriginal_2_0_local.xslt"))
 cBuff = STRT(cBuff,"<ssl-path>",CHRT(pcOpenSSL,"\","/"))
 STRTOFILE(cBuff, cXSLFile)

 cBuff = cXSLTProc + " {xsltFile} {xmlFile} > {cadFile}" + CRLF
 cBuff = STRT(cBuff,"{xsltFile}",GetShortName(FULLPATH(cXSLFile)))
 cBuff = STRT(cBuff,"{xmlFile}",GetShortName(FULLPATH(pcXML))) 
 cBuff = STRT(cBuff,"{cadFile}",cCADFile)  
 STRTOFILE(cBuff,cBATFile)


 *-- Se ejecuta el BAT
 LOCAL oWSH
 oWSH = CREATEOBJECT("WScript.Shell") 
 oWSH.Run(cBATFile, 0, .T.)
 
 *-- Se obtiene la cadena original
 LOCAL cCadenaOriginal
 cCadenaOriginal = ""
 IF FILE(cCADFile)
  cCadenaOriginal = CFDUTF82Asc(FILETOSTR(cCADFile))
 ELSE
  CFDConf.ultimoError = "Ocurrio un error inesperado al obtener la cadena original"
  cCadenaOriginal=""
 ENDIF
 
 ERASE (cCADFile)
 IF !EMPTY(cCadenaOriginal)
  ERASE (cBATFile)
  ERASE (cXSLFile)
 ENDIF 
 
 RETURN cCadenaOriginal
 *
ENDPROC




*-- CFDEnviarPorCorreo
*   Envia CFD por correo. Si se indica .T. en el parametro opcional plAdjuntarPDF, se asumira
*   que el archivo indicado en pcCFD es un XML y se procedera a generar una representacion 
*   PDF del mismo, que se adjuntara conjuntamente con el XML.
*
PROCEDURE CFDEnviarPorCorreo(pcDestinatario, pcAsunto, pcCuerpo, pcCFD, plAdjuntarPDF)
 *
 * Se prepara la configuracion a utilizar
 *
 LOCAL lcSchema, loConfig, loMsg
 lcSchema = "http://schemas.microsoft.com/cdo/configuration/"
 loConfig = CREATEOBJECT("CDO.Configuration")
 WITH loConfig.FIELDS
  .ITEM(lcSchema + "smtpserver") = CFDConf.SMTPServer
  .ITEM(lcSchema + "smtpserverport") = CFDConf.SMTPPort
  .ITEM(lcSchema + "sendusing") = 2
  .ITEM(lcSchema + "smtpauthenticate") = .T.
  .ITEM(lcSchema + "smtpusessl") = CFDConf.SMTPUseSSL
  .ITEM(lcSchema + "sendusername") = CFDConf.SMTPUserName
  .ITEM(lcSchema + "sendpassword") = CFDConf.SMTPPassword
  .UPDATE()
 ENDWITH


 * Se prepara el mensaje
 *
 loMsg = CREATEOBJECT("CDO.Message")
 WITH loMsg
  .Configuration = loConfig
  .FROM = CFDConf.MailSender
  .TO = pcDestinatario
  .Subject = pcAsunto
  .HTMLBody = pcCuerpo
  .addAttachment(FULLPATH(pcCFD))
 ENDWITH
 
 
 *-- Si se indico el parametro plAdjuntarPDF se genera un PDF
 *   del CDF y se adjunta al correo
 *
 IF plAdjuntarPDF
  *
  LOCAL cPDF
  cPDF = FORCEEXT(pcCFD,"PDF")
  CFDPrint(pcCFD,,.T.,cPDF)
  loMsg.addAttachment(FULLPATH(cPDF))
  *
 ENDIF


 * Se envia el mensaje
 *
 loMsg.Send()


 *-- Se liberan recursos
 loMsg = NULL
 loConfig = NULL
 *
ENDPROC


*-- CFDEnviarPorCorreoAdjuntos
*   Envia CFD por correo. A diferencia de CFDEnviarPorCorreo esta permite
*   adjuntar el PDF ya creado lo cuál es útil cuando se utilizan diferente
*   formatos para la representación impresa o para enviar comprobantes
*   que no generó nuestro sistema como puede ser el caso de algunos PACs
*   que junto con el timbre regresan el PDF
*
PROCEDURE CFDEnviarPorCorreoAdjuntos(pcDestinatario, pcAsunto, pcCuerpo, pcCFD, pcPDF)
 *
 * Se prepara la configuracion a utilizar
 *
 LOCAL lcSchema, loConfig, loMsg
 lcSchema = "http://schemas.microsoft.com/cdo/configuration/"
 loConfig = CREATEOBJECT("CDO.Configuration")
 WITH loConfig.FIELDS
  .ITEM(lcSchema + "smtpserver") = CFDConf.SMTPServer
  .ITEM(lcSchema + "smtpserverport") = CFDConf.SMTPPort
  .ITEM(lcSchema + "sendusing") = 2
  .ITEM(lcSchema + "smtpauthenticate") = .T.
  .ITEM(lcSchema + "smtpusessl") = CFDConf.SMTPUseSSL
  .ITEM(lcSchema + "sendusername") = CFDConf.SMTPUserName
  .ITEM(lcSchema + "sendpassword") = CFDConf.SMTPPassword
  .UPDATE()
 ENDWITH


 * Se prepara el mensaje
 *
 loMsg = CREATEOBJECT("CDO.Message")
 WITH loMsg
  .Configuration = loConfig
  .FROM = CFDConf.MailSender
  .TO = pcDestinatario
  .Subject = pcAsunto
  .HTMLBody = pcCuerpo
  IF FILE(FULLPATH(pcCFD))
    .addAttachment(FULLPATH(pcCFD))
  ENDIF 
  IF FIELD(FULLPATH(pcPDF))
    .addAttachment(FULLPATH(pcPDF))
  ENDIF 
 ENDWITH
 
 
 * Se envia el mensaje
 *
 loMsg.Send()


 *-- Se liberan recursos
 loMsg = NULL
 loConfig = NULL
 *
ENDPROC





*-- GetShortName
*   Devuelve un nombre de archivo en formato 8.3 para
*   un nombre de archivo largo dado
*
PROCEDURE GetShortName(pcLongPath)
 *
 IF NOT FILE(pcLongPath)
  MESSAGEBOX("No se pudo encontrar el archivo:" + REPL(CHR(13) + CHR(10),2) + LOWER(pcLongPath),16,"GetShortName")
  RETURN pcLongPath
 ENDIF
 
 LOCAL oFSO, oFI, cShortPath
 oFSO = CreateObject("Scripting.FileSystemObject")
 oFI = oFSO.getFile(pcLongPath)
 cShortPath = oFI.shortPath
 oFI = NULL
 oFSO = NULL
 
 RETURN cShortPath 
 *
ENDPROC




*-- GetTempFile
*   Crea un archivo temporal con la extension indicada
*
FUNCTION GetTempFile(pcExt)
 *
 IF PCOUNT() = 0
  pcExt = "TMP"
 ENDIF
 
 LOCAL cTempFile
 DO WHILE .T.
  cTempFile = FULLPATH(LEFT(SYS(2015),8) + "." + pcExt)
  IF NOT FILE(cTempFile)
   STRTOFILE("",cTempFile)
   EXIT
  ENDIF
 ENDDO  
 
 RETURN GetShortName(cTempFile)
 *
ENDFUNC


********************************************************************************************


*-- CFDLeerCertificado (Funcion)
*   Lee un certificado indicado y devuelve una instancia de la clase CFDCertificado.
*
*   Autor: Arturo Ramos / Victor Espina
*
FUNCTION CFDLeerCertificado(pcArchivoCER, pcOpenSSL)
 *
 CFDConf.UltimoError = ""
  
 *-- Se verifica que la carpeta indicada contenga el archivo OPENSSL.EXE
 IF EMPTY(pcOpenSSL)
  pcOpenSSL = CFDConf.openSSL
 ENDIF
 IF EMPTY(pcOpenSSL) OR NOT FILE(ADDBS(pcOpenSSL) + "OPENSSL.EXE")
  CFDConf.ultimoError = "No se encontro el archivo OPENSSL.EXE en la ruta indicada"
  RETURN NULL
 ENDIF
 pcOpenSSL = GetShortName(ADDBS(FULLPATH(pcOpenSSL)) + "OPENSSL.EXE")
 
 
 *-- Se prepara un archivo BAT con los comandos a ejecutar
 LOCAL cBATFile,cTempFile
 cBATFile = GetTempFile("BAT")
 cTempFile = JUSTSTEM(cBATFile)
 
 LOCAL cBuff
 cBuff = pcOpenSSL + " x509 -inform DER -outform PEM -in {cerFile} -pubkey > {tempFile}.pem " + CRLF + ;
         pcOpenSSL + " x509 -in {tempFile}.pem -serial -noout > {tempFile}.ser" + CRLF + ;
         pcOpenSSL + " x509 -inform DER -in {cerFile} -noout -startdate > {tempFile}.sta" +  + CRLF + ;
 		 pcOpenSSL + " x509 -inform DER -in {cerFile} -noout -enddate > {tempFile}.end" + CRLF 
 		 
 cBuff = STRT(cBuff,"{cerFile}",GetShortName(FULLPATH(pcArchivoCER)))
 cBuff = STRT(cBuff,"{tempFile}",cTempFile)
 STRTOFILE(cBuff,cBATFile)
 
 *-- Se ejecuta el BAT
 LOCAL oWSH
 oWSH = CREATEOBJECT("WScript.Shell") 
 oWSH.Run(cBATFile, 0, .T.)
 
 IF !FILE(cTempFile + ".PEM") OR !FILE(cTempFile + ".SER") OR !FILE(cTempFile + ".STA") OR !FILE(cTempFile + ".END")
  CFDConf.ultimoError = "Ocurrio un error al intentar leer el certificado indicado"
  ERASE (cTempFile + ".*")
  RETURN NULL
 ENDIF
 
 
 *-- Se crea el objeto a devolver
 LOCAL oData
 oData = CREATEOBJECT("CFDCertificado")
 oData.Archivo = ALLT(LOWER(pcArchivoCER))
 oData.Valido = .F.
 oData.Vigente = .F.
 oData.Certificado = ""
 oData.Serial = ""
 oData.vigenteDesde = {//::}
 oData.vigenteHasta = {//::}
 
 
 *-- Se extrae la informacion del certificado 
 LOCAL cCert
 cCert = FILETOSTR(cTempFile + ".PEM")
 cCert = SUBS(cCert,AT("-----BEGIN CERTIFICATE-----",cCert))
 cCert = STRTRAN(cCert,"-----BEGIN CERTIFICATE-----","")
 cCert = STRTRAN(cCert,"-----END CERTIFICATE-----","")
 *-- Quita saltos de linea y retornos de carro del certificado
 cCert = STRTRAN(cCert,CHR(13))
 cCert = STRTRAN(cCert,CHR(10))
 oData.Certificado = cCert


 *-- Se extrae el numero de serie del certificado
 LOCAL cSerie
 cSerie = FILETOSTR(cTempfile + ".SER")  
 cSerie = STRTRAN(cSerie,"serial=","")
 cSerie = STRTRAN(cSerie,CHR(10),"")
 cSerie = HEX2STR(cSerie)
 oData.Serial = cSerie
 
 
 *-- Se extraen las fechas de vigencia
 oData.vigenteDesde = FCTOT(cTempFile + ".STA")
 oData.vigenteHasta = FCTOT(cTempFile + ".END") 


 *-- Se completan algunos datos
 oData.Valido = (!EMPTY(oData.certificado))
 oData.Vigente = BETWEEN(DATETIME(), oData.vigenteDesde, oData.vigenteHasta)

 *-- Se eliminan los temporales creados
 ERASE (cTempFile + ".*")
 
 
 RETURN oData
 * 
ENDFUNC


*-- CFDVigenciaCert (Funcion)
*   Permite validar la caducidad del certificado
*   
*   Autor: Arturo Ramos / Victor Espina
*
FUNCTION CFDVigenciaCert(pcCER, ptFechaComp, pcOpenSSL)
 *
 * pcCER 		- archivo .cer
 * pcFechaComp 	- fecha de emisión del comprobante
 * pcOpenSSL	- path del openssl.exe
  
 *-- Se obtiene la informacion del certificado
 LOCAL oCert
 oCert = CFDLeerCertificado(pcCer,pcOpenSSL)
 IF ISNULL(oCert)
  RETURN .F.
 ENDIF
   
 CFDConf.UltimoError = ""
 
 
 *-- Se validan las fechas
 LOCAL lResult
 lResult = .T.

 IF VARTYPE(ptFechaComp) = "D"
  ptFechaComp = DTOT(ptFechaComp)
 ENDIF
  
 IF ptFechaComp < oCert.vigenteDesde THEN 
    CFDConf.ultimoError = "La fecha del comprobante es anterior a la vigencia del certificado."
 	lResult = .F.
 ENDIF 
 
 IF ptFechaComp > oCert.vigenteHasta THEN 
 	CFDConf.ultimoError = "La fecha del comprobante es posterior a la vigencia del certificado."
 	lResult = .F.
 ENDIF 
 	 
 RETURN lResult
 *
ENDPROC


*-- FCTOT (función)
*   Regresa Fecha y hora del archivo de vigencia generado con openssl obtenido del certificado
*   Al verificar la vigencia del certificado se obtienen dos archivos de texto que se pasan como parametro a la función
*   openssl.exe x509 -inform DER -in "aaa010101aaa_CSD_01.cer" -noout -enddate > "FinVigencia.txt"
*   openssl.exe x509 -inform DER -in "aaa010101aaa_CSD_01.cer" -noout -startdate > "IniciaVigencia.txt"
*
*   Basado en el código de Hugo Carlos Aguilar / Juan francisco Castro
*
*   Simplificado y adaptado a VFP6 por Victor Espina
*
Function FCTOT(pcArchivo)
 *
 LOCAL cData,cYY,cMM,cDD,cTT
 cData = CHRT(FILETOSTR(pcArchivo),CHR(13)+CHR(10),"")
 cData = SUBS(cData, AT("=",cData) + 1)
 cData = ALLT(STRT(cData,"GMT",""))
 
 cYY = RIGHT(cData,4)
 cMM = UPPER(LEFT(cData,3))
 cMM = STRT(STRT(STRT(STRT(STRT(STRT(cMM,"JAN","01"),"FEB","02"),"MAR","03"),"APR","04"),"MAY","05"),"JUN","06")
 cMM = STRT(STRT(STRT(STRT(STRT(STRT(cMM,"JUL","07"),"AUG","08"),"SEP","09"),"OCT","10"),"NOV","11"),"DEC","12")
 cDD = ALLT(SUBS(cData,5))
 cDD = PADL(LEFT(cDD,AT(" ",cDD) - 1),2,"0")
 cTT = LEFT(SUBS(cData,AT(":",cData) - 2),8)
 
 LOCAL cSetDate,tFechaHora
 cSetDate = SET("DATE")
 SET DATE YMD
 tFechaHora = CTOT(cYY + "-" + cMM + "-" + cDD + " " + cTT)
 IF cSetDate<>"YMD"
  SET DATE (cSetDate)
 ENDIF
 
 RETURN tFechaHora
 *
Endfunc



*-- CFDValidarKeyCer (Funcion)
*   Valida que los archivos KEY y CER indicados sean complementarios
*
*   Autor: Victor Espina
*
FUNCTION CFDValidarKeyCer(pcArchivoKEY, pcArchivoCER, pcPassword, pcOpenSSL)
 *
 CFDConf.UltimoError = ""
  
 *-- Se verifica que la carpeta indicada contenga el archivo OPENSSL.EXE
 IF EMPTY(pcOpenSSL)
  pcOpenSSL = CFDConf.openSSL
 ENDIF
 IF EMPTY(pcOpenSSL) OR NOT FILE(ADDBS(pcOpenSSL) + "OPENSSL.EXE")
  CFDConf.ultimoError = "No se encontro el archivo OPENSSL.EXE en la ruta indicada"
  RETURN .F.
 ENDIF
 pcOpenSSL = GetShortName(ADDBS(FULLPATH(pcOpenSSL)) + "OPENSSL.EXE")
 
 
 *-- Se prepara un archivo BAT con los comandos a ejecutar
 LOCAL cBATFile,cTempFile
 cBATFile = GetTempFile("BAT")
 cTempFile = JUSTSTEM(cBATFile)
 
 LOCAL cBuff
 cBuff = pcOpenSSL + " x509 -inform DER -in {cerFile} -noout -modulus > {tempFile}.m1" + CRLF + ;
         pcOpenSSL + " pkcs8 -inform DER -in {keyFile} -passin pass:{password} -out {tempFile}.pem" + CRLF + ;
         pcOpenSSL + " rsa -in {tempFile}.pem -noout -modulus > {tempFile}.m2" + CRLF + ;
         "DEL {tempFile}.pem" + CRLF
 		 
 cBuff = STRT(cBuff,"{cerFile}",GetShortName(FULLPATH(pcArchivoCER)))
 cBuff = STRT(cBuff,"{keyFile}",GetShortName(FULLPATH(pcArchivoKEY)))
 cBuff = STRT(cBuff,"{password}",pcPassword)
 cBuff = STRT(cBuff,"{tempFile}",cTempFile)
 STRTOFILE(cBuff,cBATFile)
 

 
 *-- Se ejecuta el BAT
 LOCAL oWSH
 oWSH = CREATEOBJECT("WScript.Shell") 
 oWSH.Run(cBATFile, 0, .T.)
 
 IF !FILE(cTempFile + ".M1") OR !FILE(cTempFile + ".M2") 
  CFDConf.ultimoError = "Ocurrio un error al intentar validar los archivos KEY y/o CER"
  ERASE (cTempFile + ".*")
  RETURN .F.
 ENDIF

 LOCAL cCerMod, cKeyMod
 cCerMod = FILETOSTR(cTempFile + ".m1")
 cKeyMod = FILETOSTR(cTempFile + ".m2")
 
 IF EMPTY(cCerMod)
  CFDConf.ultimoError = "No se pudo obtener el modulus del archivo CER"
  ERASE (cTempFile + ".*")
  RETURN .F.
 ENDIF 
 
 IF EMPTY(cKeyMod)
  CFDConf.ultimoError = "No se pudo obtener el modulus del archivo KEY (verifique la contraseña)"
  ERASE (cTempFile + ".*")
  RETURN .F.
 ENDIF 
 
 LOCAL lValid
 lValid = (cCerMod == cKeyMod)
 IF NOT lValid
  CFDConf.ultimoError = "El archivo KEY no corresponde con el archivo CER indicado"
 ENDIF
 

 *-- Se eliminan los temporales creados
 ERASE (cTempFile + ".*")
 
 
 RETURN lValid
 * 
ENDFUNC




*-- CFDValidarXML (Funcion)
*   Analiza un XML indicado y verifica que este bien formado y que
*   cumpla con los requisitos del SAT
*
*   El parametro pcMetodo debe ser "md5" o "sha1"
*
*   NOTA IMPORTANTE: Esta función valida el sello del comprobante cuando se
*   tiene el archivo .key (con su password) con el que se sello el comprobante originalmente.
*
FUNCTION CFDValidarXML(pcArchivoXML, pcArchivoKey, pcPassword, pcMetodo, pcOpenSSL)
 *
 CFDConf.ultimoError = ""
 
 *-- Se verifica que la carpeta indicada contenga el archivo OPENSSL.EXE
 IF EMPTY(pcOpenSSL)
  pcOpenSSL = CFDConf.openSSL
 ENDIF
 IF EMPTY(pcOpenSSL) OR NOT FILE(ADDBS(pcOpenSSL) + "OPENSSL.EXE")
  CFDConf.ultimoError = "No se encontro el archivo OPENSSL.EXE en la ruta indicada"
  RETURN .F.
 ENDIF
 pcOpenSSL = GetShortName(ADDBS(FULLPATH(pcOpenSSL)) + "OPENSSL.EXE")



 *-- Se verifica que el XML este bien formado
 LOCAL oXML
 oXML = CREATEOBJECT('MSXML2.DOMdocument')
 oXML.Load(GetShortName(pcArchivoXML))
 IF oXML.parseError.errorCode <> 0
  CFDConf.ultimoError = "Estructura XML mal armada. "+oXML.parseError.reason
  RETURN .F.
 ENDIF

 *-- Obtiene el nombre del nodo root, puede ser 'Comprobante' para CFD o 'cfdi:Comprobante' para CFDI
 oRootNode = oXML.documentElement
 cRootTagName = oRootNode.tagName
 
 IF cRootTagName = "cfdi:Comprobante"
  lcXSDFilev = "cfdv3.xsd"
  lcURLXSDv  = "http://www.sat.gob.mx/sitio_internet/cfd/3/cfdv3.xsd"
  lcURLXNSv  = "http://www.sat.gob.mx/cfd/3"
 ELSE 
  lcXSDFilev = "cfdv2.xsd"
  lcURLXSDv = "http://www.sat.gob.mx/sitio_internet/cfd/2/cfdv2.xsd"
  lcURLXNSv  = "http://www.sat.gob.mx/cfd/2"
 ENDIF 
 
 
 *-- Si no se cuenta con una copia local del XSD, se descarga
 IF NOT FILE(lcXSDFilev)
  STRTOFILE(GetURL(lcURLXSDv), lcXSDFilev)
 ENDIF
 
 *-- Se valida el XML cumpla con los standares del CFD/CFDI
 LOCAL lResult
 lResult = .F.
 DO CASE
    CASE FILE(ADDBS(JUSTPATH(pcOpenSSL)) + "CFDVALIDATOR.EXE") AND ;
         FILE(ADDBS(JUSTPATH(pcOpenSSL)) + "Interop.MSXML2.dll")
		 LOCAL cBATFile,cTempFile
		 cBATFile = GetTempFile("BAT")
		 cTempFile = JUSTSTEM(cBATFile)
		 
		 LOCAL cValidator,cBuff
		 cValidator = GetShortName(ADDBS(JUSTPATH(pcOpenSSL)) + "CFDVALIDATOR.EXE")
		 cBuff = cValidator + " -xml:{xmlFile} -xsd:{xsdFile} -xns:{xnsURL} > {tempFile}.out" + CRLF
		 		 
		 cBuff = STRT(cBuff,"{xmlFile}",GetShortName(pcArchivoXML))
		 cBuff = STRT(cBuff,"{xsdFile}",GetShortName(FULLPATH(lcXSDFilev)))
		 cBuff = STRT(cBuff,"{xnsURL}",lcURLXNSv)
		 cBuff = STRT(cBuff,"{tempFile}",cTempFile)
		 STRTOFILE(cBuff,cBATFile)

		 LOCAL oWSH
		 oWSH = CREATEOBJECT("WScript.Shell") 
		 oWSH.Run(cBATFile, 0, .T.)
		 
		 IF NOT FILE(cTempFile + ".OUT")
		  lResult = .F.
		  CFDConf.ultimoError = "Ocurrio un error al intentar validar el XML indicado"
		 ELSE 
		  CFDConf.ultimoError = FILETOSTR(cTempFile + ".OUT")
		  CFDConf.ultimoError = "Estructura XML mal armada. "+STRT(CFDConf.ultimoError,"[FATAL]","[ERROR]")
		  lResult = (AT("[ERROR]",CFDConf.ultimoError) = 0)
		 ENDIF
		 
		 ERASE (cTempFile + ".*")
    
    
    
    OTHERWISE
		 LOCAL oXmlDoc, oXmlSchema
		 oXmlSchema = CREATEOBJECT("MSXML2.XMLSchemaCache.6.0")
		 oXmlSchema.validateOnLoad = .T.
		 oXmlSchema.Add(lcURLXNSv, FULLPATH(lcXSDFilev))
		 oXmlDoc = CREATEOBJECT("MSXML2.DOMDocument.6.0")
		 oXmlDoc.validateOnParse = .T.
		 oXmlDoc.schemas = oXmlSchema
		 oXmlDoc.async = .F.
		 IF NOT oXmlDoc.Load(GetShortName(pcArchivoXML))
		  CFDConf.ultimoError = oXmlDoc.parseError.reason
		  lResult = .F.
		 ELSE
		  lResult = .T. 
		 ENDIF
		 oXmlDoc = NULL
		 oXmlSchema = NULL
    
 ENDCASE
 
 
 *-- Se valida el sello (solo si el XML esta OK)
 *
 IF lResult AND !EMPTY(pcArchivoKey)
  *
  LOCAL cSelloActual,cCadenaOriginal,cSelloCorrecto
  cSelloActual = MSXMLGetAttribute(oXML.selectNodes("//"+cRootTagName), "sello")
  cCadenaOriginal = CFDExtraerCadenaOriginal(pcArchivoXML, JUSTPATH(pcOpenSSL))
  cSelloCorrecto = CFDGenerarSello(cCadenaOriginal, pcArchivoKey, pcPassword, pcMetodo, JUSTPATH(pcOpenSSL))
 
  IF NOT cSelloActual == cSelloCorrecto
   CFDConf.ultimoError = CFDConf.ultimoError + ;
                         IIF(EMPTY(CFDConf.ultimoError),"",CHR(13)+CHR(10))+ ;
                         "[ERROR] El sello no es valido para este certificado." + CHR(13) + CHR(10)
   _cliptext = cCadenaOriginal
   lResult = .F.
  ENDIF
  *
 ENDIF
 
 
 RETURN lResult
 *
ENDFUNC




***********************************************
** GETURL.PRG
** Devuelve el contenido de un URL dado.
**
** Versión: 1.0
**
** Autor: Victor Espina (vespinas@cantv.net)
**        Walter Valle (wvalle@develcomp.com)
**        (basado en código original de Pablo Almunia)
*
** Fecha: 20-Agosto-2003
**
**
** Sintáxis:
** cData = GetURL(pcURL[,plVerbose])
**
** Donde:
** cData	 Contenido (texto o binario) del recurso
**			 indicado en cURL. Si ocurre algún error
**           se devolverá la cadena vacia.
** pcURL	 Dirección URL del recurso o archivo a obtener
** plVerbose Opcional. Si se establece en True, se mostrará
**		     información visual sobre el avance del proceso.
**
** Ejemplo:
** cHTML=GetURL("http://www.portalfox.com")
**
*************************************************
**
** GETURL.PRG
** Returns the contains of any given URL
**
** Version: 1.0
**
** Author: Victor Espina (vespinas@cantv.net)
**         Walter Valle (wvalle@develcomp.com)
**         (based on original source code from Pablo Almunia)
*
** Date: August 20, 2003
**
**
** Syntax:
** cData = GetURL(pcURL[,plVerbose])
**
** Where:
** cData	 Contents (text or binary) of requested URL.
** pcURL	 URL of the requested resource or file. If an
**           error occurs, a empty string will be returned.
** plVerbose Optional. If setted to True, progress info
**			 will be shown.
**
** Example:
** cHTML=GetURL("http://www.portalfox.com")
**
**************************************************
PROCEDURE GetURL
LPARAMETER pcURL,plVerbose
 *
 *-- Se definen las funciones API necesarias
 *
 #DEFINE INTERNET_OPEN_TYPE_PRECONFIG     0
 DECLARE LONG GetLastError IN WIN32API
 DECLARE INTEGER InternetCloseHandle IN "wininet.dll" ;
	LONG hInet
 DECLARE LONG InternetOpen IN "wininet.dll" ;
  STRING   lpszAgent, ;
  LONG     dwAccessType, ;
  STRING   lpszProxyName, ;
  STRING   lpszProxyBypass, ;
  LONG     dwFlags
 DECLARE LONG InternetOpenUrl IN "wininet.dll" ;
    LONG    hInet, ;
 	STRING  lpszUrl, ;
	STRING  lpszHeaders, ;
    LONG    dwHeadersLength, ;
    LONG    dwFlags, ;
    LONG    dwContext
 DECLARE LONG InternetReadFile IN "wininet.dll" ;
	LONG     hFtpSession, ;
	STRING  @lpBuffer, ;
	LONG     dwNumberOfBytesToRead, ;
	LONG    @lpNumberOfBytesRead
	
	
 *-- Se establece la conexión con internet
 *
 IF plVerbose
  WAIT "Opening Internet connection..." WINDOW NOWAIT
 ENDIF
 
 LOCAL nInetHnd
 nInetHnd = InternetOpen("GETURL",INTERNET_OPEN_TYPE_PRECONFIG,"","",0)
 IF nInetHnd = 0
  RETURN ""
 ENDIF
 
 
 *-- Se establece la conexión con el recurso
 *
 IF plVerbose
  WAIT "Opening connection to URL..." WINDOW NOWAIT
 ENDIF
 
 LOCAL nURLHnd
 nURLHnd = InternetOpenUrl(nInetHnd,pcURL,NULL,0,0,0)
 IF nURLHnd = 0
  InternetCloseHandle( nInetHnd )
  RETURN ""
 ENDIF


 *-- Se lee el contenido del recurso
 *
 LOCAL cURLData,cBuffer,nBytesReceived,nBufferSize
 cURLData=""
 cBuffer=""
 nBytesReceived=0
 nBufferSize=0

 DO WHILE .T.
  *
  *-- Se inicializa el buffer de lectura (bloques de 2 Kb)
  cBuffer=REPLICATE(CHR(0),2048)
  
  *-- Se lee el siguiente bloque
  InternetReadFile(nURLHnd,@cBuffer,LEN(cBuffer),@nBufferSize)
  IF nBufferSize = 0
   EXIT
  ENDIF
  
  *-- Se acumula el bloque en el buffer de datos
  cURLData=cURLData + SUBSTR(cBuffer,1,nBufferSize)
  nBytesReceived=nBytesReceived + nBufferSize
  
  IF plVerbose
   WAIT WINDOW ALLTRIM(TRANSFORM(INT(nBytesReceived / 1024),"999,999")) + " Kb received..." NOWAIT
  ENDIF
  *
 ENDDO
 IF plVerbose
  WAIT CLEAR
 ENDIF

 
 *-- Se cierra la conexión a Internet
 *
 InternetCloseHandle( nInetHnd )

 *-- Se devuelve el contenido del URL
 *
 RETURN cURLData
 *
ENDPROC



*-- CFDGenerarSello (Funcion)
*   Genera el sello digital en base a la cadena original dada
*
PROCEDURE CFDGenerarSello(pcCadenaOriginal, pcArchivoKey, pcPassword, pcMetodo, pcOpenSSL)
 *
 CFDConf.ultimoError = ""
 

 *-- Se verifica que la carpeta indicada contenga el archivo OPENSSL.EXE
 IF EMPTY(pcOpenSSL)
  pcOpenSSL = CFDConf.openSSL
 ENDIF
 IF EMPTY(pcOpenSSL) OR NOT FILE(ADDBS(pcOpenSSL) + "OPENSSL.EXE")
  CFDConf.ultimoError = "No se encontro el archivo OPENSSL.EXE en la ruta indicada"
  RETURN ""
 ENDIF
 pcOpenSSL = GetShortName(ADDBS(FULLPATH(pcOpenSSL)) + "OPENSSL.EXE")
 
  
 *-- Obtenemos un archivo temporal que no exista, con extension .BAT
 LOCAL cBatFile,cTempFile
 cBatFile = GetTempFile("BAT")
  
  
 *-- Tomamos solo la parte del nombre del archivo. Este nombre se utilizara para
 *   crear otros archivos temporales, con distintas extensiones. Esto evita que
 *   dos estaciones puedan "cruzarse" al intentar sellar al mismo tiempo
 cTempFile = JUSTSTEM(cBatFile)
  
  
 *-- Se genera el contenido del archivo BAT para generar el sello
 LOCAL cBuff
 cBuff = pcOpenSSL + " pkcs8 -inform DER -in {keyFile} -passin pass:{password} -out {tempFile}.pem" + CRLF + ;
         pcOpenSSL + " dgst -{metodo} -sign {tempFile}.pem {tempFile}.cad | " + pcOpenSSL + " enc -base64 -A > {tempFile}.sea" + CRLF + ;
         "del {tempFile}.cad" + CRLF + ;
         "del {tempFile}.pem" + CRLF  && Metodo correcto
         

 *-- Se crea el archivo STR con la cadena original
 STRTOFILE(CFDAsc2UTF8(pcCadenaOriginal),cTempFile + ".cad")
  
 *-- Se crea el archivo BAT personalizado para esta operacion
 cBuff = STRT(cBuff,"{keyFile}",GetShortName(pcArchivoKey))
 cBuff = STRT(cBuff,"{password}",pcPassword)
 cBuff = STRT(cBuff,"{tempFile}",cTempFile)
 cBuff = STRT(cBuff,"{metodo}",pcMetodo)
 STRTOFILE(cBuff,cBatFile)

 *-- Se ejecuta el archivo BAT
 LOCAL oWSH
 oWSH = CREATEOBJECT("WScript.Shell")
 oWSH.Run(cBatFile,0,.T.)
 
 
 *-- Si todo salio bien, tenemos un archivo .SEA con el sello
 LOCAL cSello
 IF FILE(cTempFile + ".SEA")
  cSello = FILETOSTR(cTempFile + ".SEA")
 ELSE
  CFDConf.ultimoError = "Ocurrio un error al calcular el sello digital"
  cSello = "" 
 ENDIF
 ERASE (cTempFile + ".*")  
 
 RETURN cSello
 *
ENDPROC



*-- MSXMLGetAttribute
*   Devuelve el valor de un atributo dado en un nodo XML especifico
*
*   Autor: Victor Espina
*   Fecha: Dic 29, 2010
*
FUNCTION MSXMLGetAttribute(poNodo, pcAttribute)
 *
 LOCAL nCount, i, cValue
 nCount = poNodo.Item(0).Attributes.Length - 1
 cValue = ""
 pcAttribute = UPPER(pcAttribute)
 FOR i = 0 TO nCount
  IF UPPER(poNodo.Item(0).Attributes.Item(i).nodeName) == pcAttribute
   cValue = poNodo.Item(0).Attributes.Item(i).TEXT
  ENDIF
 ENDFOR
 
 RETURN cValue
 *
ENDFUNC


DEFINE CLASS CFDReporteMensual AS Custom
 *
 RFCEmisor = ""
 Mes = ""
 Ano = ""
 Registros = NULL
 dataCursor = ""
 
 *-- Constructor
 *
 PROCEDURE Init
  *
  THIS.dataCursor = SYS(2015)
  SELECT 0
  CREATE CURSOR (THIS.dataCursor) ;
   ( ;
     rfc       C (13),;
     serie     C (10),;
     folio     N (10),;
     noAprob   C (20),;
     anoAprob  C (4),;
     fechahora T,;
     fecha     D,;
     total     N (15,2),;
     traslados N (15,2),;
     excento   L,;
     estado    C (1),;
     efecto    C (1),;
     pedimento C (254),;
     fechapedi C (254),;
     aduanaped C (254) ;
   )
  *
 ENDPROC
 
 
 *-- Add (Metodo)
 *   Permite incluir un registro en el reporte con los minimos datos posibles
 *
 PROCEDURE Add(pcRFC, pcSerie, pnFolio, pcNoAprobacion, pcAnoAprobacion, ptFecha, pnTotal, pnTraslados, pcEstado, pcEfecto, pcPedimentos, pcFechaPedimentos, pcAduanaPedimentos)
  *
  SELECT (THIS.dataCursor)
  APPEND BLANK
  REPLACE rfc       WITH pcRFC,;
          serie     WITH pcSerie,;
          folio     WITH pnFolio,;
          noAprob   WITH pcNoAprobacion,;
          anoAprob  WITH pcAnoAprobacion,;
          fechahora WITH ptFecha,;
          fecha     WITH TTOD(ptFecha),;
          total     WITH pnTotal,;
          traslados WITH NVL(pnTraslados,0.00),;
          excento   WITH ISNULL(pnTraslados),;
          estado    WITH IIF(VARTYPE(pnEstado)<>"C","1",pcEstado),;
          efecto    WITH IIF(VARTYPE(pcEfecto)<>"C","I",pcEFecto),;
          pedimento WITH IIF(EMPTY(pcPedimentos),"",pcPedimentos),;
          fechapedi WITH IIF(EMPTY(pcFechaPedimentos),"",pcFechaPedimentos),;
          aduanaped WITH IIF(EMPTY(pcAduanaPedimentos),"",pcAduanaPedimentos)
          
  LOCAL oRow
  SCATTER NAME oRow
  
  RETURN oRow
  *
 ENDPROC
 
 
 
 *-- generarTXT (Metodo)
 *   Genera el TXT para el SAT 
 *
 PROCEDURE generarTXT(pcDestino)
  *
  *-- Se construye el nombre del archivo
  LOCAL cFileName
  cFileName = "1" + RTRIM(THIS.rfcEmisor) + PADL(THIS.Mes,2,"0") + PADL(THIS.Ano,4,"0") + ".TXT"
  
  *-- Si no se indico la ruta, se asume la actual
  IF EMPTY(pcDestino) OR NOT DIRECTORY(pcDestino)
   pcDestino = SET("DEFAULT") + CURDIR()
  ENDIF
  cFileName = ADDBS(pcDestino) + cFileName


  *-- Se obtiene un cursor ordenado con los datos a reportar
  LOCAL cCursor1
  cCursor1 = THIS.dataCursor + "_Q1"
  SELECT * ;
    FROM (THIS.dataCursor)  ;
   ORDER BY serie, folio ;
    INTO CURSOR (cCursor1)
 
 
  *-- Se genera el contenido del archivo
  LOCAL cBuff,i,oRow,cLine
  cBuff = ""
  
  SELECT (cCursor1)
  GO TOP
  SCAN
   cLine = THIS._fixStr(rfc) + "|" + ;
           THIS._fixStr(serie) + "|" + ;
           THIS._fixStr(STR(folio)) + "|" + ;
           THIS._fixStr(ALLT(anoAprob)+ALLT(noAprob)) + "|" + ;
           PADL(DAY(fechahora),2,"0") + "/" + PADL(MONTH(fechahora),2,"0") + "/" + STR(YEAR(fechahora),4) + " " + ;
           PADL(HOUR(fechahora),2,"0") + ":" + PADL(MINUTE(fechahora),2,"0") + ":" + PADL(SEC(fechahora),2,"0") + "|" + ;
           THIS._fixStr(STR(total,15,2)) + "|" + ;
           IIF(excento,"",THIS._fixStr(STR(traslados,15,2))) + "|" + ;
           THIS._fixStr(estado) + "|" + ;
           THIS._fixStr(efecto) + "|" + ;
           THIS._fixStr(pedimento) + "|" + ;
           THIS._fixStr(fechapedi) + "|" + ;
           THIS._fixStr(aduanaped) 
                  
   cBuff = cBuff + "|" + cLine + "|" + CRLF               
  ENDSCAN
  USE IN (cCursor1)
  
  STRTOFILE(cBuff, cFileName)  
  
  RETURN cFileName
  *
 ENDPROC
 
 
 *-- _fixStr (Metodo)
 *   Elimina cualquier valor incorrecto en la cadena dada
 *
 HIDDEN PROCEDURE _FixStr(pcString)
  *
  IF ISNULL(pcString)
   RETURN ""
  ENDIF
  
  pcString = ALLT(CHRT(pcString,"|",""))
  
  RETURN pcString
  *
 ENDPROC
 *
ENDDEFINE


*-- CFDRegistroReporteMensual (Clase)
*   Representa un registro dentro del reporte mensual de CFD
*
DEFINE CLASS CFDLineaReporteMensual AS Custom
 *
 RFC = ""
 Serie = ""
 Folio = 0
 noAprobacion = ""
 anoAprobacion = ""
 FechaHora = {//::}
 Total = 0.00
 Traslados = 0.00
 Estado = 0
 Efecto = ""
 Pedimento = ""
 FechaPedimento = ""
 Aduana = ""
 *
ENDDEFINE



*-- CFDProbarOpenSSL (Funcion)
*   Verifica el correcto funcionamiento de OpenSSL
*
PROCEDURE CFDProbarOpenSSL(pcOpenSSL)
 *
 CFDConf.ultimoError = ""
 

 *-- Se verifica que la carpeta indicada contenga el archivo OPENSSL.EXE
 IF EMPTY(pcOpenSSL)
  pcOpenSSL = CFDConf.openSSL
 ENDIF
 IF EMPTY(pcOpenSSL) OR NOT FILE(ADDBS(pcOpenSSL) + "OPENSSL.EXE")
  CFDConf.ultimoError = "No se encontro el archivo OPENSSL.EXE en la ruta indicada"
  RETURN .F.
 ENDIF
 pcOpenSSL = GetShortName(ADDBS(FULLPATH(pcOpenSSL)) + "OPENSSL.EXE")
 
  
 *-- Obtenemos un archivo temporal que no exista, con extension .BAT
 LOCAL cBatFile,cTempFile
 cBatFile = GetTempFile("BAT")
  
  
 *-- Tomamos solo la parte del nombre del archivo. Este nombre se utilizara para
 *   crear otros archivos temporales, con distintas extensiones. Esto evita que
 *   dos estaciones puedan "cruzarse" al intentar sellar al mismo tiempo
 cTempFile = JUSTSTEM(cBatFile)
  
  
 *-- Se genera el contenido del archivo BAT para generar el sello
 LOCAL cBuff
 cBuff = pcOpenSSL + " version > {tempFile}.out" + CRLF 
         

 *-- Se crea el archivo BAT personalizado para esta operacion
 cBuff = STRT(cBuff,"{tempFile}",cTempFile)
 STRTOFILE(cBuff,cBatFile)

 *-- Se ejecuta el archivo BAT
 LOCAL oWSH
 oWSH = CREATEOBJECT("WScript.Shell")
 oWSH.Run(cBatFile,0,.T.)
 
 
 *-- Si todo salio bien, tenemos un archivo .OUT con la informacion de version del OpenSSL
 LOCAL cResult,lOk
 cResult = FILETOSTR(cTempFile + ".OUT")
 ERASE (cTempFile + ".*")
 
 lOk = (ATC("OpenSSL",cResult)<>0)
 CFDConf.ultimoError = cResult
 
 RETURN lOk
 *
ENDPROC

*-- CFDITimbraFacturaxion
*   Envia el xml a timbrar con la empresa Facturaxion
*	www.facturaxion.com
*   Autor: Rulo
*   Fecha: 26 Ago 2011
*	Parametros: 
*	cXMLCFD			Cadena que contiene el XML sin timbrar (y sin addendas)
*	cCodUsuarioProv	Codigo del usuario ante el proveedor
*	cCodUsuario		Codigo del usuario
*	cIDSucursal		Id de Sucursal
FUNCTION CFDITimbraFacturaxion
PARAMETERS cXMLCFD, cCodUsuarioProv, cCodUsuario, cIDSucursal

ENDFUNC



*-- CFDCadenaCBB (Funcion)
*   Analiza un XML indicado (con timbre) y regresa la cadena para generar el CBB
*   según los requisitos del SAT
*
*
FUNCTION CFDCadenaCBB(pcArchivoXML)
	* -- Codigo de barras QRCode
	* Anexo 20
	* 1. RFC del emisor
	* 2. RFC del receptor
	* 3. Total (a 6 decimales fijos)
	* 4. Identificador único del timbre (UUID) asignado
	* 
	* 95 caracteres conformados de la siguiente manera
	* -> RFC del Emisor, a 12/13 posiciones, precedido por el texto / ?re= / 17 caracteres
	* -> RFC del Receptor, a 12/13 posiciones, precedido por el texto / &rr= / 17 caracteres
	* -> Total del comprobante a 17 posiciones (10 para los enteros, 
	*      1 para carácter ., 6 para los decimales), precedido por el texto / &tt= / 21 caracteres
	* -> UUID del comprobante, precedido por el texto / &id= / 40 caracteres
	*
	* -- Genera la cadena a codificar
	LOCAL cCodifica, cRFCEmisor, cRFCReceptor, cTotal, cUUID
	cCodifica = ''
	
	* Lee desde el XML del CFDI
	oCFDI = CREATEOBJECT('MSXML2.DOMdocument')
	oCFDI.load(pcArchivoXML)
	IF (oCFDI.parseError.errorCode <> 0) THEN 
	   myErr = oXML.parseError
	   CFDConf.ultimoError = myErr.reason
	  *MESSAGEBOX("Estructura XML del comprobante mal armado: " + myErr.reason, 16, "Sistema")
	   cCodifica = ''
	ELSE 
		* Selecciona el nodo Emisor para sacar el atributo RFC
		olNode = oCFDI.selectSingleNode("//cfdi:Comprobante/cfdi:Emisor")
		IF ISNULL(olNode) THEN 
			CFDConf.ultimoError = "XML inválido. Nodo <cfdi:Emisor> no presente."
			*MESSAGEBOX("XML inválido."+CHR(13)+"Nodo <cfdi:Emisor> no presente.", 16, "Sistema")
			cCodifica = ''
		ELSE 
			cRFCEmisor = olNode.getAttribute("rfc")
		ENDIF
		
		* Selecciona el nodo Receptor para sacar el atributo RFC
		olNode = oCFDI.selectSingleNode("//cfdi:Comprobante/cfdi:Receptor")
		IF ISNULL(olNode) THEN 
			CFDConf.ultimoError = "XML inválido. Nodo <cfdi:Receptor> no presente."
			*MESSAGEBOX("XML inválido."+CHR(13)+"Nodo <cfdi:Receptor> no presente.", 16, "Sistema")
			cCodifica = ''
		ELSE 
			cRFCReceptor = olNode.getAttribute("rfc")
		ENDIF
		
		* Selecciona el nodo Comprobante para sacar el atributo RFC
		olNode = oCFDI.selectSingleNode("//cfdi:Comprobante")
		IF ISNULL(olNode) THEN 
			CFDConf.ultimoError = "XML inválido. Nodo <cfdi:Comprobante> no presente."
			*MESSAGEBOX("XML inválido."+CHR(13)+"Nodo <cfdi:Comprobante> no presente.", 16, "Sistema")
			cCodifica = ''
		ELSE 
			cTotal = olNode.getAttribute("total")
			cTotal = PADL(SUBSTR(cTotal, 1, ATC('.', cTotal)-1), 10, '0')+'.'+PADR(RIGHT(cTotal, LEN(cTotal)-ATC('.', cTotal)), 6, '0')
		ENDIF
		
		* Selecciona el nodo TimbreFiscalDigital para sacar el atributo UUID
		olNode = oCFDI.selectSingleNode("//cfdi:Comprobante/cfdi:Complemento/tfd:TimbreFiscalDigital")
		IF ISNULL(olNode) THEN 
			CFDConf.ultimoError = "XML inválido. Nodo <tfd:TimbreFiscalDigital> no presente."
			*MESSAGEBOX("XML inválido."+CHR(13)+"Nodo <tfd:TimbreFiscalDigital> no presente.", 16, "Sistema")
			cCodifica = ''
		ELSE 
			cUUID = olNode.getAttribute("UUID")
		ENDIF
		
	ENDIF
	
	cCodifica = '?re='+cRFCEmisor+'&rr='+cRFCReceptor+'&tt='+cTotal+'&id='+cUUID
	
	RETURN cCodifica
ENDFUNC 


* -----------------------------------------
FUNCTION CFDGoogleQR(tcDato) 
* -----------------------------------------
* Esta funcion genera un código de barras bidimensional
* utilizando la Api de Google: http://code.google.com/intl/es-AR/apis/chart/docs/gallery/qr_codes.html
*
* Recibe de parámetro la cadena a codificar y 
* regresa el nombre del png generado.
* 
* La idea es agregarlo al formato gráfico, para que se genere la imagen, con algo así:
*
* CFDGoogleQR(CFDCadenaCBB(pcArchivoXML))
*
* Autor: Baltazar Moreno
* Fecha: Octubre 07, 2011
* -----------------------------------------

	lcDimensiones = '200x200'
	lcImagen = ADDBS(SYS(2023)) + SYS(2015)+"_googleQR.png"   && En temporal de windows

*	WAIT WINDOW "Generando y descargando Código QR, espere por favor..." NOWAIT 
	DECLARE Long URLDownloadToFile IN "urlmon"; 
	  Long pCaller,; 
	  String szURL,; 
	  String szFileName,; 
	  Long dwReserved,; 
	  Long lpfnCB 
	lcURL ="https://chart.googleapis.com/chart?cht=qr&chs=" + ;
	      lcDimensiones + "&chld=M&chl=" + CFDGetEscaped(tcDato, 0x2000) 
	nRetVal = URLDownloadToFile (0, lcURL, lcImagen, 0, 0) 
*	WAIT CLEAR 

	RETURN IIF( nRetVal == 0 , lcImagen	, "" )

ENDFUNC
* -----------------------------------------

* -----------------------------------------
FUNCTION CFDGetEscaped(tcSource, tnFlag)
* -----------------------------------------
* Esta funcion convierte los caracteres no soportados en la URL
* En sus cadenas de escape, más info:
* http://www.news2news.com/vfp/?example=396&function=617&PHPSESSID=0e0804f1a28f0d2e8d8a0af3b257f808
* 
* Autor: Baltazar Moreno
* Fecha: Octubre 07, 2011
* -----------------------------------------
    DECLARE INTEGER UrlEscape IN shlwapi;
        STRING pszURL, STRING @pszEscaped,;
        INTEGER @pcchEscaped, INTEGER dwFlags
 
    LOCAL cTarget, nBufsize
    nBufsize = Len(tcSource) * 4
    cTarget = Repli(Chr(0), nBufsize)
    = UrlEscape(tcSource, @cTarget, @nBufsize, tnFlag)
RETURN Left(cTarget, nBufsize)
ENDFUNC 
* -----------------------------------------


*-- CFDEVL
*   Implementacion de la funcion EVL()
* 
*   Autor: V Espina
*   Fecha: 11 Nov 2011
*
PROCEDURE CFDEVL(puValue, puDefault)
 RETURN IIF(EMPTY(puValue),puDEfault,puValue)
ENDPROC


*-- CFDBuffer
*   Funcion para crear un buffer de datos e inicializarlo
*
*   Autor: V Espina
*   Fecha: Nov 12, 2011
*
*   Ejemplo:
*   oBuff = CFDBuffer("Nombre,Apellido","Victor","Espina")
*   ?oBuff.Nombre -> "Victor"
*   ?oBuff.Apellido -> "Espina"
*
PROCEDURE CFDBuffer
LPARAMETERS pcItemList,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19
 *
 LOCAL oBuff,i,cProp
 oBuff=CREATEOBJECT("Custom")

 LOCAL cPropName,uPropValue,nCount
 LOCAL ARRAY aProps[1]
 nCount = ALINES(aProps,STRT(pcItemList,",",CHR(13)+CHR(10)))
 FOR i=1 TO MIN(nCount,20)
  cPropName = aProps[i]
  uPropValue = EVALUATE("P" + ALLTRIM(STR(i - 1)))
  oBuff.AddProperty(cPropName, uPropValue)
 ENDFOR
 
 RETURN oBuff
 *
ENDPROC

